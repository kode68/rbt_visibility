{"ast":null,"code":"'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport ownerDocument from '@mui/utils/ownerDocument';\nimport useLazyRef from '@mui/utils/useLazyRef';\nimport useLayoutEffect from '@mui/utils/useEnhancedEffect';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport { throttle } from '@mui/x-internals/throttle';\nimport { isDeepEqual } from '@mui/x-internals/isDeepEqual';\nimport { roundToDecimalPlaces } from '@mui/x-internals/math';\nimport { useStore, useStoreEffect, createSelectorMemoized } from '@mui/x-internals/store';\nimport { Size } from \"../models/index.js\";\n/* eslint-disable import/export, @typescript-eslint/no-redeclare */\n/* eslint-disable no-underscore-dangle */\n\nconst EMPTY_DIMENSIONS = {\n  isReady: false,\n  root: Size.EMPTY,\n  viewportOuterSize: Size.EMPTY,\n  viewportInnerSize: Size.EMPTY,\n  contentSize: Size.EMPTY,\n  minimumSize: Size.EMPTY,\n  hasScrollX: false,\n  hasScrollY: false,\n  scrollbarSize: 0,\n  headerHeight: 0,\n  groupHeaderHeight: 0,\n  headerFilterHeight: 0,\n  rowWidth: 0,\n  rowHeight: 0,\n  columnsTotalWidth: 0,\n  leftPinnedWidth: 0,\n  rightPinnedWidth: 0,\n  headersTotalHeight: 0,\n  topContainerHeight: 0,\n  bottomContainerHeight: 0\n};\nconst selectors = {\n  rootSize: state => state.rootSize,\n  dimensions: state => state.dimensions,\n  rowHeight: state => state.dimensions.rowHeight,\n  rowsMeta: state => state.rowsMeta,\n  columnPositions: createSelectorMemoized((_, columns) => {\n    const positions = [];\n    let currentPosition = 0;\n    for (let i = 0; i < columns.length; i += 1) {\n      positions.push(currentPosition);\n      currentPosition += columns[i].computedWidth;\n    }\n    return positions;\n  }),\n  needsHorizontalScrollbar: state => state.dimensions.viewportOuterSize.width > 0 && state.dimensions.columnsTotalWidth > state.dimensions.viewportOuterSize.width\n};\nexport const Dimensions = {\n  initialize: initializeState,\n  use: useDimensions,\n  selectors\n};\nfunction initializeState(params) {\n  const dimensions = _extends({}, EMPTY_DIMENSIONS, params.dimensions);\n  const {\n    rowCount\n  } = params;\n  const {\n    rowHeight\n  } = dimensions;\n  const rowsMeta = {\n    currentPageTotalHeight: rowCount * rowHeight,\n    positions: Array.from({\n      length: rowCount\n    }, (_, i) => i * rowHeight),\n    pinnedTopRowsTotalHeight: 0,\n    pinnedBottomRowsTotalHeight: 0\n  };\n  const rowHeights = new Map();\n  return {\n    rootSize: Size.EMPTY,\n    dimensions,\n    rowsMeta,\n    rowHeights\n  };\n}\nfunction useDimensions(store, params, _api) {\n  const isFirstSizing = React.useRef(true);\n  const {\n    refs,\n    dimensions: {\n      rowHeight,\n      headerHeight,\n      columnsTotalWidth,\n      groupHeaderHeight,\n      headerFilterHeight,\n      headersTotalHeight,\n      leftPinnedWidth,\n      rightPinnedWidth\n    }\n  } = params;\n  const updateDimensions = React.useCallback(() => {\n    if (isFirstSizing.current) {\n      return;\n    }\n    const rootSize = selectors.rootSize(store.state);\n    const rowsMeta = selectors.rowsMeta(store.state);\n\n    // All the floating point dimensions should be rounded to .1 decimal places to avoid subpixel rendering issues\n    // https://github.com/mui/mui-x/issues/9550#issuecomment-1619020477\n    // https://github.com/mui/mui-x/issues/15721\n    const scrollbarSize = measureScrollbarSize(params.refs.container.current, params.scrollbarSize);\n    const topContainerHeight = headersTotalHeight + rowsMeta.pinnedTopRowsTotalHeight;\n    const bottomContainerHeight = rowsMeta.pinnedBottomRowsTotalHeight;\n    const contentSize = {\n      width: columnsTotalWidth,\n      height: roundToDecimalPlaces(rowsMeta.currentPageTotalHeight, 1)\n    };\n    let viewportOuterSize;\n    let viewportInnerSize;\n    let hasScrollX = false;\n    let hasScrollY = false;\n    if (params.autoHeight) {\n      hasScrollY = false;\n      hasScrollX = Math.round(columnsTotalWidth) > Math.round(rootSize.width);\n      viewportOuterSize = {\n        width: rootSize.width,\n        height: topContainerHeight + bottomContainerHeight + contentSize.height\n      };\n      viewportInnerSize = {\n        width: Math.max(0, viewportOuterSize.width - (hasScrollY ? scrollbarSize : 0)),\n        height: Math.max(0, viewportOuterSize.height - (hasScrollX ? scrollbarSize : 0))\n      };\n    } else {\n      viewportOuterSize = {\n        width: rootSize.width,\n        height: rootSize.height\n      };\n      viewportInnerSize = {\n        width: Math.max(0, viewportOuterSize.width),\n        height: Math.max(0, viewportOuterSize.height - topContainerHeight - bottomContainerHeight)\n      };\n      const content = contentSize;\n      const container = viewportInnerSize;\n      const hasScrollXIfNoYScrollBar = content.width > container.width;\n      const hasScrollYIfNoXScrollBar = content.height > container.height;\n      if (hasScrollXIfNoYScrollBar || hasScrollYIfNoXScrollBar) {\n        hasScrollY = hasScrollYIfNoXScrollBar;\n        hasScrollX = content.width + (hasScrollY ? scrollbarSize : 0) > container.width;\n\n        // We recalculate the scroll y to consider the size of the x scrollbar.\n        if (hasScrollX) {\n          hasScrollY = content.height + scrollbarSize > container.height;\n        }\n      }\n      if (hasScrollY) {\n        viewportInnerSize.width -= scrollbarSize;\n      }\n      if (hasScrollX) {\n        viewportInnerSize.height -= scrollbarSize;\n      }\n    }\n    const rowWidth = Math.max(viewportOuterSize.width, columnsTotalWidth + (hasScrollY ? scrollbarSize : 0));\n    const minimumSize = {\n      width: columnsTotalWidth,\n      height: topContainerHeight + contentSize.height + bottomContainerHeight\n    };\n    const newDimensions = {\n      isReady: true,\n      root: rootSize,\n      viewportOuterSize,\n      viewportInnerSize,\n      contentSize,\n      minimumSize,\n      hasScrollX,\n      hasScrollY,\n      scrollbarSize,\n      headerHeight,\n      groupHeaderHeight,\n      headerFilterHeight,\n      rowWidth,\n      rowHeight,\n      columnsTotalWidth,\n      leftPinnedWidth,\n      rightPinnedWidth,\n      headersTotalHeight,\n      topContainerHeight,\n      bottomContainerHeight\n    };\n    const prevDimensions = store.state.dimensions;\n    if (isDeepEqual(prevDimensions, newDimensions)) {\n      return;\n    }\n    store.update({\n      dimensions: newDimensions\n    });\n  }, [store, params.refs.container, params.scrollbarSize, params.autoHeight, rowHeight, headerHeight, groupHeaderHeight, headerFilterHeight, columnsTotalWidth, headersTotalHeight, leftPinnedWidth, rightPinnedWidth]);\n  const {\n    resizeThrottleMs,\n    onResize\n  } = params;\n  const updateDimensionCallback = useEventCallback(updateDimensions);\n  const debouncedUpdateDimensions = React.useMemo(() => resizeThrottleMs > 0 ? throttle(() => {\n    updateDimensionCallback();\n    onResize === null || onResize === void 0 || onResize(store.state.rootSize);\n  }, resizeThrottleMs) : undefined, [resizeThrottleMs, onResize, store, updateDimensionCallback]);\n  React.useEffect(() => debouncedUpdateDimensions === null || debouncedUpdateDimensions === void 0 ? void 0 : debouncedUpdateDimensions.clear, [debouncedUpdateDimensions]);\n  useLayoutEffect(() => observeRootNode(refs.container.current, store), [refs, store]);\n  useLayoutEffect(updateDimensions, [updateDimensions]);\n  useStoreEffect(store, selectors.rootSize, (_, size) => {\n    var _params$onResize;\n    (_params$onResize = params.onResize) === null || _params$onResize === void 0 || _params$onResize.call(params, size);\n    if (isFirstSizing.current || !debouncedUpdateDimensions) {\n      // We want to initialize the grid dimensions as soon as possible to avoid flickering\n      isFirstSizing.current = false;\n      updateDimensions();\n    } else {\n      debouncedUpdateDimensions();\n    }\n  });\n  const rowsMeta = useRowsMeta(store, params, updateDimensions);\n  return {\n    updateDimensions,\n    debouncedUpdateDimensions,\n    rowsMeta\n  };\n}\nfunction useRowsMeta(store, params, updateDimensions) {\n  const heightCache = store.state.rowHeights;\n  const {\n    rows,\n    getRowHeight: getRowHeightProp,\n    getRowSpacing,\n    getEstimatedRowHeight\n  } = params;\n  const lastMeasuredRowIndex = React.useRef(-1);\n  const hasRowWithAutoHeight = React.useRef(false);\n  const isHeightMetaValid = React.useRef(false);\n  const pinnedRows = params.pinnedRows;\n  const rowHeight = useStore(store, selectors.rowHeight);\n  const getRowHeightEntry = useEventCallback(rowId => {\n    let entry = heightCache.get(rowId);\n    if (entry === undefined) {\n      entry = {\n        content: store.state.dimensions.rowHeight,\n        spacingTop: 0,\n        spacingBottom: 0,\n        detail: 0,\n        autoHeight: false,\n        needsFirstMeasurement: true\n      };\n      heightCache.set(rowId, entry);\n    }\n    return entry;\n  });\n  const {\n    rowIdToIndexMap,\n    applyRowHeight\n  } = params;\n  const processHeightEntry = React.useCallback(row => {\n    // HACK: rowHeight trails behind the most up-to-date value just enough to\n    // mess the initial rowsMeta hydration :/\n    eslintUseValue(rowHeight);\n    const dimensions = selectors.dimensions(store.state);\n    const baseRowHeight = dimensions.rowHeight;\n    const entry = getRowHeightEntry(row.id);\n    if (!getRowHeightProp) {\n      entry.content = baseRowHeight;\n      entry.needsFirstMeasurement = false;\n    } else {\n      const rowHeightFromUser = getRowHeightProp(row);\n      if (rowHeightFromUser === 'auto') {\n        if (entry.needsFirstMeasurement) {\n          const estimatedRowHeight = getEstimatedRowHeight ? getEstimatedRowHeight(row) : baseRowHeight;\n\n          // If the row was not measured yet use the estimated row height\n          entry.content = estimatedRowHeight !== null && estimatedRowHeight !== void 0 ? estimatedRowHeight : baseRowHeight;\n        }\n        hasRowWithAutoHeight.current = true;\n        entry.autoHeight = true;\n      } else {\n        // Default back to base rowHeight if getRowHeight returns null value.\n        entry.content = rowHeightFromUser !== null && rowHeightFromUser !== void 0 ? rowHeightFromUser : dimensions.rowHeight;\n        entry.needsFirstMeasurement = false;\n        entry.autoHeight = false;\n      }\n    }\n    if (getRowSpacing) {\n      var _rowIdToIndexMap$get, _spacing$top, _spacing$bottom;\n      const indexRelativeToCurrentPage = (_rowIdToIndexMap$get = rowIdToIndexMap.get(row.id)) !== null && _rowIdToIndexMap$get !== void 0 ? _rowIdToIndexMap$get : -1;\n      const spacing = getRowSpacing(row, {\n        isFirstVisible: indexRelativeToCurrentPage === 0,\n        isLastVisible: indexRelativeToCurrentPage === rows.length - 1,\n        indexRelativeToCurrentPage\n      });\n      entry.spacingTop = (_spacing$top = spacing.top) !== null && _spacing$top !== void 0 ? _spacing$top : 0;\n      entry.spacingBottom = (_spacing$bottom = spacing.bottom) !== null && _spacing$bottom !== void 0 ? _spacing$bottom : 0;\n    } else {\n      entry.spacingTop = 0;\n      entry.spacingBottom = 0;\n    }\n    applyRowHeight === null || applyRowHeight === void 0 || applyRowHeight(entry, row);\n    return entry;\n  }, [store, rows, getRowHeightProp, getRowHeightEntry, getEstimatedRowHeight, rowHeight, getRowSpacing, rowIdToIndexMap, applyRowHeight]);\n  const hydrateRowsMeta = React.useCallback(() => {\n    hasRowWithAutoHeight.current = false;\n    const pinnedTopRowsTotalHeight = pinnedRows.top.reduce((acc, row) => {\n      const entry = processHeightEntry(row);\n      return acc + entry.content + entry.spacingTop + entry.spacingBottom + entry.detail;\n    }, 0);\n    const pinnedBottomRowsTotalHeight = pinnedRows.bottom.reduce((acc, row) => {\n      const entry = processHeightEntry(row);\n      return acc + entry.content + entry.spacingTop + entry.spacingBottom + entry.detail;\n    }, 0);\n    const positions = [];\n    const currentPageTotalHeight = rows.reduce((acc, row) => {\n      positions.push(acc);\n      const entry = processHeightEntry(row);\n      const total = entry.content + entry.spacingTop + entry.spacingBottom + entry.detail;\n      return acc + total;\n    }, 0);\n    if (!hasRowWithAutoHeight.current) {\n      // No row has height=auto, so all rows are already measured\n      lastMeasuredRowIndex.current = Infinity;\n    }\n    const didHeightsChange = pinnedTopRowsTotalHeight !== store.state.rowsMeta.pinnedTopRowsTotalHeight || pinnedBottomRowsTotalHeight !== store.state.rowsMeta.pinnedBottomRowsTotalHeight || currentPageTotalHeight !== store.state.rowsMeta.currentPageTotalHeight;\n    const rowsMeta = {\n      currentPageTotalHeight,\n      positions,\n      pinnedTopRowsTotalHeight,\n      pinnedBottomRowsTotalHeight\n    };\n    store.set('rowsMeta', rowsMeta);\n    if (didHeightsChange) {\n      updateDimensions();\n    }\n    isHeightMetaValid.current = true;\n  }, [store, pinnedRows, rows, processHeightEntry, updateDimensions]);\n  const hydrateRowsMetaLatest = useEventCallback(hydrateRowsMeta);\n  const getRowHeight = rowId => {\n    var _heightCache$get$cont, _heightCache$get;\n    return (_heightCache$get$cont = (_heightCache$get = heightCache.get(rowId)) === null || _heightCache$get === void 0 ? void 0 : _heightCache$get.content) !== null && _heightCache$get$cont !== void 0 ? _heightCache$get$cont : selectors.rowHeight(store.state);\n  };\n  const storeRowHeightMeasurement = (id, height) => {\n    const entry = getRowHeightEntry(id);\n    const didChange = entry.content !== height;\n    entry.needsFirstMeasurement = false;\n    entry.content = height;\n    isHeightMetaValid.current && (isHeightMetaValid.current = !didChange);\n  };\n  const rowHasAutoHeight = id => {\n    var _heightCache$get$auto, _heightCache$get2;\n    return (_heightCache$get$auto = (_heightCache$get2 = heightCache.get(id)) === null || _heightCache$get2 === void 0 ? void 0 : _heightCache$get2.autoHeight) !== null && _heightCache$get$auto !== void 0 ? _heightCache$get$auto : false;\n  };\n  const getLastMeasuredRowIndex = () => {\n    return lastMeasuredRowIndex.current;\n  };\n  const setLastMeasuredRowIndex = index => {\n    if (hasRowWithAutoHeight.current && index > lastMeasuredRowIndex.current) {\n      lastMeasuredRowIndex.current = index;\n    }\n  };\n  const resetRowHeights = () => {\n    heightCache.clear();\n    hydrateRowsMeta();\n  };\n  const resizeObserver = useLazyRef(() => typeof ResizeObserver === 'undefined' ? undefined : new ResizeObserver(entries => {\n    for (let i = 0; i < entries.length; i += 1) {\n      var _params$focusedVirtua;\n      const entry = entries[i];\n      const height = entry.borderBoxSize && entry.borderBoxSize.length > 0 ? entry.borderBoxSize[0].blockSize : entry.contentRect.height;\n      const rowId = entry.target.__mui_id;\n      const focusedVirtualRowId = (_params$focusedVirtua = params.focusedVirtualCell()) === null || _params$focusedVirtua === void 0 ? void 0 : _params$focusedVirtua.id;\n      if (focusedVirtualRowId === rowId && height === 0) {\n        // Focused virtual row has 0 height.\n        // We don't want to store it to avoid scroll jumping.\n        // https://github.com/mui/mui-x/issues/14726\n        return;\n      }\n      storeRowHeightMeasurement(rowId, height);\n    }\n    if (!isHeightMetaValid.current) {\n      // Avoids \"ResizeObserver loop completed with undelivered notifications\" error\n      requestAnimationFrame(() => {\n        hydrateRowsMetaLatest();\n      });\n    }\n  })).current;\n  const observeRowHeight = (element, rowId) => {\n    element.__mui_id = rowId;\n    resizeObserver === null || resizeObserver === void 0 || resizeObserver.observe(element);\n    return () => resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.unobserve(element);\n  };\n\n  // The effect is used to build the rows meta data - currentPageTotalHeight and positions.\n  // Because of variable row height this is needed for the virtualization\n  useLayoutEffect(() => {\n    hydrateRowsMeta();\n  }, [hydrateRowsMeta]);\n  return {\n    getRowHeight,\n    setLastMeasuredRowIndex,\n    storeRowHeightMeasurement,\n    hydrateRowsMeta,\n    observeRowHeight,\n    rowHasAutoHeight,\n    getRowHeightEntry,\n    getLastMeasuredRowIndex,\n    resetRowHeights\n  };\n}\nfunction observeRootNode(node, store) {\n  if (!node) {\n    return undefined;\n  }\n  const bounds = node.getBoundingClientRect();\n  const initialSize = {\n    width: roundToDecimalPlaces(bounds.width, 1),\n    height: roundToDecimalPlaces(bounds.height, 1)\n  };\n  if (store.state.rootSize === Size.EMPTY || !Size.equals(initialSize, store.state.rootSize)) {\n    store.update({\n      rootSize: initialSize\n    });\n  }\n  if (typeof ResizeObserver === 'undefined') {\n    return undefined;\n  }\n  const observer = new ResizeObserver(_ref => {\n    let [entry] = _ref;\n    if (!entry) {\n      return;\n    }\n    const rootSize = {\n      width: roundToDecimalPlaces(entry.contentRect.width, 1),\n      height: roundToDecimalPlaces(entry.contentRect.height, 1)\n    };\n    if (!Size.equals(rootSize, store.state.rootSize)) {\n      store.update({\n        rootSize\n      });\n    }\n  });\n  observer.observe(node);\n  return () => {\n    observer.disconnect();\n  };\n}\nconst scrollbarSizeCache = new WeakMap();\nfunction measureScrollbarSize(element, scrollbarSize) {\n  if (scrollbarSize !== undefined) {\n    return scrollbarSize;\n  }\n  if (element === null) {\n    return 0;\n  }\n  const cachedSize = scrollbarSizeCache.get(element);\n  if (cachedSize !== undefined) {\n    return cachedSize;\n  }\n  const doc = ownerDocument(element);\n  const scrollDiv = doc.createElement('div');\n  scrollDiv.style.width = '99px';\n  scrollDiv.style.height = '99px';\n  scrollDiv.style.position = 'absolute';\n  scrollDiv.style.overflow = 'scroll';\n  scrollDiv.className = 'scrollDiv';\n  element.appendChild(scrollDiv);\n  const size = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n  element.removeChild(scrollDiv);\n  scrollbarSizeCache.set(element, size);\n  return size;\n}\nfunction eslintUseValue(_) {}","map":{"version":3,"names":["_extends","React","ownerDocument","useLazyRef","useLayoutEffect","useEventCallback","throttle","isDeepEqual","roundToDecimalPlaces","useStore","useStoreEffect","createSelectorMemoized","Size","EMPTY_DIMENSIONS","isReady","root","EMPTY","viewportOuterSize","viewportInnerSize","contentSize","minimumSize","hasScrollX","hasScrollY","scrollbarSize","headerHeight","groupHeaderHeight","headerFilterHeight","rowWidth","rowHeight","columnsTotalWidth","leftPinnedWidth","rightPinnedWidth","headersTotalHeight","topContainerHeight","bottomContainerHeight","selectors","rootSize","state","dimensions","rowsMeta","columnPositions","_","columns","positions","currentPosition","i","length","push","computedWidth","needsHorizontalScrollbar","width","Dimensions","initialize","initializeState","use","useDimensions","params","rowCount","currentPageTotalHeight","Array","from","pinnedTopRowsTotalHeight","pinnedBottomRowsTotalHeight","rowHeights","Map","store","_api","isFirstSizing","useRef","refs","updateDimensions","useCallback","current","measureScrollbarSize","container","height","autoHeight","Math","round","max","content","hasScrollXIfNoYScrollBar","hasScrollYIfNoXScrollBar","newDimensions","prevDimensions","update","resizeThrottleMs","onResize","updateDimensionCallback","debouncedUpdateDimensions","useMemo","undefined","useEffect","clear","observeRootNode","size","_params$onResize","call","useRowsMeta","heightCache","rows","getRowHeight","getRowHeightProp","getRowSpacing","getEstimatedRowHeight","lastMeasuredRowIndex","hasRowWithAutoHeight","isHeightMetaValid","pinnedRows","getRowHeightEntry","rowId","entry","get","spacingTop","spacingBottom","detail","needsFirstMeasurement","set","rowIdToIndexMap","applyRowHeight","processHeightEntry","row","eslintUseValue","baseRowHeight","id","rowHeightFromUser","estimatedRowHeight","_rowIdToIndexMap$get","_spacing$top","_spacing$bottom","indexRelativeToCurrentPage","spacing","isFirstVisible","isLastVisible","top","bottom","hydrateRowsMeta","reduce","acc","total","Infinity","didHeightsChange","hydrateRowsMetaLatest","_heightCache$get$cont","_heightCache$get","storeRowHeightMeasurement","didChange","rowHasAutoHeight","_heightCache$get$auto","_heightCache$get2","getLastMeasuredRowIndex","setLastMeasuredRowIndex","index","resetRowHeights","resizeObserver","ResizeObserver","entries","_params$focusedVirtua","borderBoxSize","blockSize","contentRect","target","__mui_id","focusedVirtualRowId","focusedVirtualCell","requestAnimationFrame","observeRowHeight","element","observe","unobserve","node","bounds","getBoundingClientRect","initialSize","equals","observer","_ref","disconnect","scrollbarSizeCache","WeakMap","cachedSize","doc","scrollDiv","createElement","style","position","overflow","className","appendChild","offsetWidth","clientWidth","removeChild"],"sources":["C:/Users/mis/rbt-dashboard/node_modules/@mui/x-virtualizer/esm/features/dimensions.js"],"sourcesContent":["'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport ownerDocument from '@mui/utils/ownerDocument';\nimport useLazyRef from '@mui/utils/useLazyRef';\nimport useLayoutEffect from '@mui/utils/useEnhancedEffect';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport { throttle } from '@mui/x-internals/throttle';\nimport { isDeepEqual } from '@mui/x-internals/isDeepEqual';\nimport { roundToDecimalPlaces } from '@mui/x-internals/math';\nimport { useStore, useStoreEffect, createSelectorMemoized } from '@mui/x-internals/store';\nimport { Size } from \"../models/index.js\";\n/* eslint-disable import/export, @typescript-eslint/no-redeclare */\n/* eslint-disable no-underscore-dangle */\n\nconst EMPTY_DIMENSIONS = {\n  isReady: false,\n  root: Size.EMPTY,\n  viewportOuterSize: Size.EMPTY,\n  viewportInnerSize: Size.EMPTY,\n  contentSize: Size.EMPTY,\n  minimumSize: Size.EMPTY,\n  hasScrollX: false,\n  hasScrollY: false,\n  scrollbarSize: 0,\n  headerHeight: 0,\n  groupHeaderHeight: 0,\n  headerFilterHeight: 0,\n  rowWidth: 0,\n  rowHeight: 0,\n  columnsTotalWidth: 0,\n  leftPinnedWidth: 0,\n  rightPinnedWidth: 0,\n  headersTotalHeight: 0,\n  topContainerHeight: 0,\n  bottomContainerHeight: 0\n};\nconst selectors = {\n  rootSize: state => state.rootSize,\n  dimensions: state => state.dimensions,\n  rowHeight: state => state.dimensions.rowHeight,\n  rowsMeta: state => state.rowsMeta,\n  columnPositions: createSelectorMemoized((_, columns) => {\n    const positions = [];\n    let currentPosition = 0;\n    for (let i = 0; i < columns.length; i += 1) {\n      positions.push(currentPosition);\n      currentPosition += columns[i].computedWidth;\n    }\n    return positions;\n  }),\n  needsHorizontalScrollbar: state => state.dimensions.viewportOuterSize.width > 0 && state.dimensions.columnsTotalWidth > state.dimensions.viewportOuterSize.width\n};\nexport const Dimensions = {\n  initialize: initializeState,\n  use: useDimensions,\n  selectors\n};\nfunction initializeState(params) {\n  const dimensions = _extends({}, EMPTY_DIMENSIONS, params.dimensions);\n  const {\n    rowCount\n  } = params;\n  const {\n    rowHeight\n  } = dimensions;\n  const rowsMeta = {\n    currentPageTotalHeight: rowCount * rowHeight,\n    positions: Array.from({\n      length: rowCount\n    }, (_, i) => i * rowHeight),\n    pinnedTopRowsTotalHeight: 0,\n    pinnedBottomRowsTotalHeight: 0\n  };\n  const rowHeights = new Map();\n  return {\n    rootSize: Size.EMPTY,\n    dimensions,\n    rowsMeta,\n    rowHeights\n  };\n}\nfunction useDimensions(store, params, _api) {\n  const isFirstSizing = React.useRef(true);\n  const {\n    refs,\n    dimensions: {\n      rowHeight,\n      headerHeight,\n      columnsTotalWidth,\n      groupHeaderHeight,\n      headerFilterHeight,\n      headersTotalHeight,\n      leftPinnedWidth,\n      rightPinnedWidth\n    }\n  } = params;\n  const updateDimensions = React.useCallback(() => {\n    if (isFirstSizing.current) {\n      return;\n    }\n    const rootSize = selectors.rootSize(store.state);\n    const rowsMeta = selectors.rowsMeta(store.state);\n\n    // All the floating point dimensions should be rounded to .1 decimal places to avoid subpixel rendering issues\n    // https://github.com/mui/mui-x/issues/9550#issuecomment-1619020477\n    // https://github.com/mui/mui-x/issues/15721\n    const scrollbarSize = measureScrollbarSize(params.refs.container.current, params.scrollbarSize);\n    const topContainerHeight = headersTotalHeight + rowsMeta.pinnedTopRowsTotalHeight;\n    const bottomContainerHeight = rowsMeta.pinnedBottomRowsTotalHeight;\n    const contentSize = {\n      width: columnsTotalWidth,\n      height: roundToDecimalPlaces(rowsMeta.currentPageTotalHeight, 1)\n    };\n    let viewportOuterSize;\n    let viewportInnerSize;\n    let hasScrollX = false;\n    let hasScrollY = false;\n    if (params.autoHeight) {\n      hasScrollY = false;\n      hasScrollX = Math.round(columnsTotalWidth) > Math.round(rootSize.width);\n      viewportOuterSize = {\n        width: rootSize.width,\n        height: topContainerHeight + bottomContainerHeight + contentSize.height\n      };\n      viewportInnerSize = {\n        width: Math.max(0, viewportOuterSize.width - (hasScrollY ? scrollbarSize : 0)),\n        height: Math.max(0, viewportOuterSize.height - (hasScrollX ? scrollbarSize : 0))\n      };\n    } else {\n      viewportOuterSize = {\n        width: rootSize.width,\n        height: rootSize.height\n      };\n      viewportInnerSize = {\n        width: Math.max(0, viewportOuterSize.width),\n        height: Math.max(0, viewportOuterSize.height - topContainerHeight - bottomContainerHeight)\n      };\n      const content = contentSize;\n      const container = viewportInnerSize;\n      const hasScrollXIfNoYScrollBar = content.width > container.width;\n      const hasScrollYIfNoXScrollBar = content.height > container.height;\n      if (hasScrollXIfNoYScrollBar || hasScrollYIfNoXScrollBar) {\n        hasScrollY = hasScrollYIfNoXScrollBar;\n        hasScrollX = content.width + (hasScrollY ? scrollbarSize : 0) > container.width;\n\n        // We recalculate the scroll y to consider the size of the x scrollbar.\n        if (hasScrollX) {\n          hasScrollY = content.height + scrollbarSize > container.height;\n        }\n      }\n      if (hasScrollY) {\n        viewportInnerSize.width -= scrollbarSize;\n      }\n      if (hasScrollX) {\n        viewportInnerSize.height -= scrollbarSize;\n      }\n    }\n    const rowWidth = Math.max(viewportOuterSize.width, columnsTotalWidth + (hasScrollY ? scrollbarSize : 0));\n    const minimumSize = {\n      width: columnsTotalWidth,\n      height: topContainerHeight + contentSize.height + bottomContainerHeight\n    };\n    const newDimensions = {\n      isReady: true,\n      root: rootSize,\n      viewportOuterSize,\n      viewportInnerSize,\n      contentSize,\n      minimumSize,\n      hasScrollX,\n      hasScrollY,\n      scrollbarSize,\n      headerHeight,\n      groupHeaderHeight,\n      headerFilterHeight,\n      rowWidth,\n      rowHeight,\n      columnsTotalWidth,\n      leftPinnedWidth,\n      rightPinnedWidth,\n      headersTotalHeight,\n      topContainerHeight,\n      bottomContainerHeight\n    };\n    const prevDimensions = store.state.dimensions;\n    if (isDeepEqual(prevDimensions, newDimensions)) {\n      return;\n    }\n    store.update({\n      dimensions: newDimensions\n    });\n  }, [store, params.refs.container, params.scrollbarSize, params.autoHeight, rowHeight, headerHeight, groupHeaderHeight, headerFilterHeight, columnsTotalWidth, headersTotalHeight, leftPinnedWidth, rightPinnedWidth]);\n  const {\n    resizeThrottleMs,\n    onResize\n  } = params;\n  const updateDimensionCallback = useEventCallback(updateDimensions);\n  const debouncedUpdateDimensions = React.useMemo(() => resizeThrottleMs > 0 ? throttle(() => {\n    updateDimensionCallback();\n    onResize?.(store.state.rootSize);\n  }, resizeThrottleMs) : undefined, [resizeThrottleMs, onResize, store, updateDimensionCallback]);\n  React.useEffect(() => debouncedUpdateDimensions?.clear, [debouncedUpdateDimensions]);\n  useLayoutEffect(() => observeRootNode(refs.container.current, store), [refs, store]);\n  useLayoutEffect(updateDimensions, [updateDimensions]);\n  useStoreEffect(store, selectors.rootSize, (_, size) => {\n    params.onResize?.(size);\n    if (isFirstSizing.current || !debouncedUpdateDimensions) {\n      // We want to initialize the grid dimensions as soon as possible to avoid flickering\n      isFirstSizing.current = false;\n      updateDimensions();\n    } else {\n      debouncedUpdateDimensions();\n    }\n  });\n  const rowsMeta = useRowsMeta(store, params, updateDimensions);\n  return {\n    updateDimensions,\n    debouncedUpdateDimensions,\n    rowsMeta\n  };\n}\nfunction useRowsMeta(store, params, updateDimensions) {\n  const heightCache = store.state.rowHeights;\n  const {\n    rows,\n    getRowHeight: getRowHeightProp,\n    getRowSpacing,\n    getEstimatedRowHeight\n  } = params;\n  const lastMeasuredRowIndex = React.useRef(-1);\n  const hasRowWithAutoHeight = React.useRef(false);\n  const isHeightMetaValid = React.useRef(false);\n  const pinnedRows = params.pinnedRows;\n  const rowHeight = useStore(store, selectors.rowHeight);\n  const getRowHeightEntry = useEventCallback(rowId => {\n    let entry = heightCache.get(rowId);\n    if (entry === undefined) {\n      entry = {\n        content: store.state.dimensions.rowHeight,\n        spacingTop: 0,\n        spacingBottom: 0,\n        detail: 0,\n        autoHeight: false,\n        needsFirstMeasurement: true\n      };\n      heightCache.set(rowId, entry);\n    }\n    return entry;\n  });\n  const {\n    rowIdToIndexMap,\n    applyRowHeight\n  } = params;\n  const processHeightEntry = React.useCallback(row => {\n    // HACK: rowHeight trails behind the most up-to-date value just enough to\n    // mess the initial rowsMeta hydration :/\n    eslintUseValue(rowHeight);\n    const dimensions = selectors.dimensions(store.state);\n    const baseRowHeight = dimensions.rowHeight;\n    const entry = getRowHeightEntry(row.id);\n    if (!getRowHeightProp) {\n      entry.content = baseRowHeight;\n      entry.needsFirstMeasurement = false;\n    } else {\n      const rowHeightFromUser = getRowHeightProp(row);\n      if (rowHeightFromUser === 'auto') {\n        if (entry.needsFirstMeasurement) {\n          const estimatedRowHeight = getEstimatedRowHeight ? getEstimatedRowHeight(row) : baseRowHeight;\n\n          // If the row was not measured yet use the estimated row height\n          entry.content = estimatedRowHeight ?? baseRowHeight;\n        }\n        hasRowWithAutoHeight.current = true;\n        entry.autoHeight = true;\n      } else {\n        // Default back to base rowHeight if getRowHeight returns null value.\n        entry.content = rowHeightFromUser ?? dimensions.rowHeight;\n        entry.needsFirstMeasurement = false;\n        entry.autoHeight = false;\n      }\n    }\n    if (getRowSpacing) {\n      const indexRelativeToCurrentPage = rowIdToIndexMap.get(row.id) ?? -1;\n      const spacing = getRowSpacing(row, {\n        isFirstVisible: indexRelativeToCurrentPage === 0,\n        isLastVisible: indexRelativeToCurrentPage === rows.length - 1,\n        indexRelativeToCurrentPage\n      });\n      entry.spacingTop = spacing.top ?? 0;\n      entry.spacingBottom = spacing.bottom ?? 0;\n    } else {\n      entry.spacingTop = 0;\n      entry.spacingBottom = 0;\n    }\n    applyRowHeight?.(entry, row);\n    return entry;\n  }, [store, rows, getRowHeightProp, getRowHeightEntry, getEstimatedRowHeight, rowHeight, getRowSpacing, rowIdToIndexMap, applyRowHeight]);\n  const hydrateRowsMeta = React.useCallback(() => {\n    hasRowWithAutoHeight.current = false;\n    const pinnedTopRowsTotalHeight = pinnedRows.top.reduce((acc, row) => {\n      const entry = processHeightEntry(row);\n      return acc + entry.content + entry.spacingTop + entry.spacingBottom + entry.detail;\n    }, 0);\n    const pinnedBottomRowsTotalHeight = pinnedRows.bottom.reduce((acc, row) => {\n      const entry = processHeightEntry(row);\n      return acc + entry.content + entry.spacingTop + entry.spacingBottom + entry.detail;\n    }, 0);\n    const positions = [];\n    const currentPageTotalHeight = rows.reduce((acc, row) => {\n      positions.push(acc);\n      const entry = processHeightEntry(row);\n      const total = entry.content + entry.spacingTop + entry.spacingBottom + entry.detail;\n      return acc + total;\n    }, 0);\n    if (!hasRowWithAutoHeight.current) {\n      // No row has height=auto, so all rows are already measured\n      lastMeasuredRowIndex.current = Infinity;\n    }\n    const didHeightsChange = pinnedTopRowsTotalHeight !== store.state.rowsMeta.pinnedTopRowsTotalHeight || pinnedBottomRowsTotalHeight !== store.state.rowsMeta.pinnedBottomRowsTotalHeight || currentPageTotalHeight !== store.state.rowsMeta.currentPageTotalHeight;\n    const rowsMeta = {\n      currentPageTotalHeight,\n      positions,\n      pinnedTopRowsTotalHeight,\n      pinnedBottomRowsTotalHeight\n    };\n    store.set('rowsMeta', rowsMeta);\n    if (didHeightsChange) {\n      updateDimensions();\n    }\n    isHeightMetaValid.current = true;\n  }, [store, pinnedRows, rows, processHeightEntry, updateDimensions]);\n  const hydrateRowsMetaLatest = useEventCallback(hydrateRowsMeta);\n  const getRowHeight = rowId => {\n    return heightCache.get(rowId)?.content ?? selectors.rowHeight(store.state);\n  };\n  const storeRowHeightMeasurement = (id, height) => {\n    const entry = getRowHeightEntry(id);\n    const didChange = entry.content !== height;\n    entry.needsFirstMeasurement = false;\n    entry.content = height;\n    isHeightMetaValid.current &&= !didChange;\n  };\n  const rowHasAutoHeight = id => {\n    return heightCache.get(id)?.autoHeight ?? false;\n  };\n  const getLastMeasuredRowIndex = () => {\n    return lastMeasuredRowIndex.current;\n  };\n  const setLastMeasuredRowIndex = index => {\n    if (hasRowWithAutoHeight.current && index > lastMeasuredRowIndex.current) {\n      lastMeasuredRowIndex.current = index;\n    }\n  };\n  const resetRowHeights = () => {\n    heightCache.clear();\n    hydrateRowsMeta();\n  };\n  const resizeObserver = useLazyRef(() => typeof ResizeObserver === 'undefined' ? undefined : new ResizeObserver(entries => {\n    for (let i = 0; i < entries.length; i += 1) {\n      const entry = entries[i];\n      const height = entry.borderBoxSize && entry.borderBoxSize.length > 0 ? entry.borderBoxSize[0].blockSize : entry.contentRect.height;\n      const rowId = entry.target.__mui_id;\n      const focusedVirtualRowId = params.focusedVirtualCell()?.id;\n      if (focusedVirtualRowId === rowId && height === 0) {\n        // Focused virtual row has 0 height.\n        // We don't want to store it to avoid scroll jumping.\n        // https://github.com/mui/mui-x/issues/14726\n        return;\n      }\n      storeRowHeightMeasurement(rowId, height);\n    }\n    if (!isHeightMetaValid.current) {\n      // Avoids \"ResizeObserver loop completed with undelivered notifications\" error\n      requestAnimationFrame(() => {\n        hydrateRowsMetaLatest();\n      });\n    }\n  })).current;\n  const observeRowHeight = (element, rowId) => {\n    element.__mui_id = rowId;\n    resizeObserver?.observe(element);\n    return () => resizeObserver?.unobserve(element);\n  };\n\n  // The effect is used to build the rows meta data - currentPageTotalHeight and positions.\n  // Because of variable row height this is needed for the virtualization\n  useLayoutEffect(() => {\n    hydrateRowsMeta();\n  }, [hydrateRowsMeta]);\n  return {\n    getRowHeight,\n    setLastMeasuredRowIndex,\n    storeRowHeightMeasurement,\n    hydrateRowsMeta,\n    observeRowHeight,\n    rowHasAutoHeight,\n    getRowHeightEntry,\n    getLastMeasuredRowIndex,\n    resetRowHeights\n  };\n}\nfunction observeRootNode(node, store) {\n  if (!node) {\n    return undefined;\n  }\n  const bounds = node.getBoundingClientRect();\n  const initialSize = {\n    width: roundToDecimalPlaces(bounds.width, 1),\n    height: roundToDecimalPlaces(bounds.height, 1)\n  };\n  if (store.state.rootSize === Size.EMPTY || !Size.equals(initialSize, store.state.rootSize)) {\n    store.update({\n      rootSize: initialSize\n    });\n  }\n  if (typeof ResizeObserver === 'undefined') {\n    return undefined;\n  }\n  const observer = new ResizeObserver(([entry]) => {\n    if (!entry) {\n      return;\n    }\n    const rootSize = {\n      width: roundToDecimalPlaces(entry.contentRect.width, 1),\n      height: roundToDecimalPlaces(entry.contentRect.height, 1)\n    };\n    if (!Size.equals(rootSize, store.state.rootSize)) {\n      store.update({\n        rootSize\n      });\n    }\n  });\n  observer.observe(node);\n  return () => {\n    observer.disconnect();\n  };\n}\nconst scrollbarSizeCache = new WeakMap();\nfunction measureScrollbarSize(element, scrollbarSize) {\n  if (scrollbarSize !== undefined) {\n    return scrollbarSize;\n  }\n  if (element === null) {\n    return 0;\n  }\n  const cachedSize = scrollbarSizeCache.get(element);\n  if (cachedSize !== undefined) {\n    return cachedSize;\n  }\n  const doc = ownerDocument(element);\n  const scrollDiv = doc.createElement('div');\n  scrollDiv.style.width = '99px';\n  scrollDiv.style.height = '99px';\n  scrollDiv.style.position = 'absolute';\n  scrollDiv.style.overflow = 'scroll';\n  scrollDiv.className = 'scrollDiv';\n  element.appendChild(scrollDiv);\n  const size = scrollDiv.offsetWidth - scrollDiv.clientWidth;\n  element.removeChild(scrollDiv);\n  scrollbarSizeCache.set(element, size);\n  return size;\n}\nfunction eslintUseValue(_) {}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}