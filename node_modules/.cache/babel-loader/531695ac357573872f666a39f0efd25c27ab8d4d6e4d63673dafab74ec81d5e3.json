{"ast":null,"code":"'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport useLazyRef from '@mui/utils/useLazyRef';\nimport useTimeout from '@mui/utils/useTimeout';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport * as platform from '@mui/x-internals/platform';\nimport { useRunOnce } from '@mui/x-internals/useRunOnce';\nimport { useFirstRender } from '@mui/x-internals/useFirstRender';\nimport { createSelector, useStore, useStoreEffect } from '@mui/x-internals/store';\nimport { Dimensions } from \"./dimensions.js\";\nimport { ScrollDirection } from \"../models/index.js\";\n\n/* eslint-disable import/export, @typescript-eslint/no-redeclare */\n\nconst clamp = (value, min, max) => Math.max(min, Math.min(max, value));\nconst MINIMUM_COLUMN_WIDTH = 50;\nconst EMPTY_SCROLL_POSITION = {\n  top: 0,\n  left: 0\n};\nconst EMPTY_DETAIL_PANELS = Object.freeze(new Map());\nexport const EMPTY_RENDER_CONTEXT = {\n  firstRowIndex: 0,\n  lastRowIndex: 0,\n  firstColumnIndex: 0,\n  lastColumnIndex: 0\n};\nconst selectors = {\n  renderContext: createSelector(state => state.virtualization.renderContext),\n  enabledForRows: createSelector(state => state.virtualization.enabledForRows),\n  enabledForColumns: createSelector(state => state.virtualization.enabledForColumns)\n};\nexport const Virtualization = {\n  initialize: initializeState,\n  use: useVirtualization,\n  selectors\n};\nfunction initializeState(params) {\n  const state = {\n    virtualization: _extends({\n      enabled: !platform.isJSDOM,\n      enabledForRows: !platform.isJSDOM,\n      enabledForColumns: !platform.isJSDOM,\n      renderContext: EMPTY_RENDER_CONTEXT\n    }, params.initialState?.virtualization),\n    // FIXME: refactor once the state shape is settled\n    getters: null\n  };\n  return state;\n}\n\n/** APIs to override for colspan/rowspan */\n\nfunction useVirtualization(store, params, api) {\n  const {\n    initialState,\n    isRtl,\n    rows,\n    range,\n    columns,\n    pinnedRows,\n    pinnedColumns,\n    refs,\n    hasColSpan,\n    dimensions: {\n      rowHeight,\n      columnsTotalWidth\n    },\n    contentHeight,\n    minimalContentHeight,\n    autoHeight,\n    onWheel,\n    onTouchMove,\n    onRenderContextChange,\n    onScrollChange,\n    rowBufferPx,\n    columnBufferPx,\n    scrollReset,\n    renderRow,\n    renderInfiniteLoadingTrigger\n  } = params;\n  const needsHorizontalScrollbar = useStore(store, Dimensions.selectors.needsHorizontalScrollbar);\n  const hasBottomPinnedRows = pinnedRows.bottom.length > 0;\n  const [panels, setPanels] = React.useState(EMPTY_DETAIL_PANELS);\n  const isRenderContextReady = React.useRef(false);\n  const renderContext = useStore(store, selectors.renderContext);\n  const enabledForRows = useStore(store, selectors.enabledForRows);\n  const enabledForColumns = useStore(store, selectors.enabledForColumns);\n\n  /*\n   * Scroll context logic\n   * ====================\n   * We only render the cells contained in the `renderContext`. However, when the user starts scrolling the grid\n   * in a direction, we want to render as many cells as possible in that direction, as to avoid presenting white\n   * areas if the user scrolls too fast/far and the viewport ends up in a region we haven't rendered yet. To render\n   * more cells, we store some offsets to add to the viewport in `scrollCache.buffer`. Those offsets make the render\n   * context wider in the direction the user is going, but also makes the buffer around the viewport `0` for the\n   * dimension (horizontal or vertical) in which the user is not scrolling. So if the normal viewport is 8 columns\n   * wide, with a 1 column buffer (10 columns total), then we want it to be exactly 8 columns wide during vertical\n   * scroll.\n   * However, we don't want the rows in the old context to re-render from e.g. 10 columns to 8 columns, because that's\n   * work that's not necessary. Thus we store the context at the start of the scroll in `frozenContext`, and the rows\n   * that are part of this old context will keep their same render context as to avoid re-rendering.\n   */\n  const scrollPosition = React.useRef(initialState?.scroll ?? EMPTY_SCROLL_POSITION);\n  const ignoreNextScrollEvent = React.useRef(false);\n  const previousContextScrollPosition = React.useRef(EMPTY_SCROLL_POSITION);\n  const previousRowContext = React.useRef(EMPTY_RENDER_CONTEXT);\n  const scrollTimeout = useTimeout();\n  const frozenContext = React.useRef(undefined);\n  const scrollCache = useLazyRef(() => createScrollCache(isRtl, rowBufferPx, columnBufferPx, rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6)).current;\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    if (areRenderContextsEqual(nextRenderContext, store.state.virtualization.renderContext)) {\n      return;\n    }\n    const didRowsIntervalChange = nextRenderContext.firstRowIndex !== previousRowContext.current.firstRowIndex || nextRenderContext.lastRowIndex !== previousRowContext.current.lastRowIndex;\n    store.set('virtualization', _extends({}, store.state.virtualization, {\n      renderContext: nextRenderContext\n    }));\n\n    // The lazy-loading hook is listening to `renderedRowsIntervalChange`,\n    // but only does something if we already have a render context, because\n    // otherwise we would call an update directly on mount\n    const isReady = Dimensions.selectors.dimensions(store.state).isReady;\n    if (isReady && didRowsIntervalChange) {\n      previousRowContext.current = nextRenderContext;\n      onRenderContextChange?.(nextRenderContext);\n    }\n    previousContextScrollPosition.current = scrollPosition.current;\n  }, [store, onRenderContextChange]);\n  const triggerUpdateRenderContext = useEventCallback(() => {\n    const scroller = refs.scroller.current;\n    if (!scroller) {\n      return undefined;\n    }\n    const dimensions = Dimensions.selectors.dimensions(store.state);\n    const maxScrollTop = Math.ceil(dimensions.minimumSize.height - dimensions.viewportOuterSize.height);\n    const maxScrollLeft = Math.ceil(dimensions.minimumSize.width - dimensions.viewportInnerSize.width);\n\n    // Clamp the scroll position to the viewport to avoid re-calculating the render context for scroll bounce\n    const newScroll = {\n      top: clamp(scroller.scrollTop, 0, maxScrollTop),\n      left: isRtl ? clamp(scroller.scrollLeft, -maxScrollLeft, 0) : clamp(scroller.scrollLeft, 0, maxScrollLeft)\n    };\n    const dx = newScroll.left - scrollPosition.current.left;\n    const dy = newScroll.top - scrollPosition.current.top;\n    const isScrolling = dx !== 0 || dy !== 0;\n    scrollPosition.current = newScroll;\n    const direction = isScrolling ? directionForDelta(dx, dy) : ScrollDirection.NONE;\n\n    // Since previous render, we have scrolled...\n    const rowScroll = Math.abs(scrollPosition.current.top - previousContextScrollPosition.current.top);\n    const columnScroll = Math.abs(scrollPosition.current.left - previousContextScrollPosition.current.left);\n\n    // PERF: use the computed minimum column width instead of a static one\n    const didCrossThreshold = rowScroll >= rowHeight || columnScroll >= MINIMUM_COLUMN_WIDTH;\n    const didChangeDirection = scrollCache.direction !== direction;\n    const shouldUpdate = didCrossThreshold || didChangeDirection;\n    if (!shouldUpdate) {\n      return renderContext;\n    }\n\n    // Render a new context\n\n    if (didChangeDirection) {\n      switch (direction) {\n        case ScrollDirection.NONE:\n        case ScrollDirection.LEFT:\n        case ScrollDirection.RIGHT:\n          frozenContext.current = undefined;\n          break;\n        default:\n          frozenContext.current = renderContext;\n          break;\n      }\n    }\n    scrollCache.direction = direction;\n    scrollCache.buffer = bufferForDirection(isRtl, direction, rowBufferPx, columnBufferPx, rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6);\n    const inputs = inputsSelector(store, params, api, enabledForRows, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    if (!areRenderContextsEqual(nextRenderContext, renderContext)) {\n      // Prevents batching render context changes\n      ReactDOM.flushSync(() => {\n        updateRenderContext(nextRenderContext);\n      });\n      scrollTimeout.start(1000, triggerUpdateRenderContext);\n    }\n    return nextRenderContext;\n  });\n  const forceUpdateRenderContext = useEventCallback(() => {\n    // skip update if dimensions are not ready and virtualization is enabled\n    if (!Dimensions.selectors.dimensions(store.state).isReady && (enabledForRows || enabledForColumns)) {\n      return;\n    }\n    const inputs = inputsSelector(store, params, api, enabledForRows, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    // Reset the frozen context when the render context changes, see the illustration in https://github.com/mui/mui-x/pull/12353\n    frozenContext.current = undefined;\n    updateRenderContext(nextRenderContext);\n  });\n  const handleScroll = useEventCallback(() => {\n    if (ignoreNextScrollEvent.current) {\n      ignoreNextScrollEvent.current = false;\n      return;\n    }\n    const nextRenderContext = triggerUpdateRenderContext();\n    if (nextRenderContext) {\n      onScrollChange?.(scrollPosition.current, nextRenderContext);\n    }\n  });\n\n  /**\n   * HACK: unstable_rowTree fixes the issue described below, but does it by tightly coupling this\n   * section of code to the DataGrid's rowTree model. The `unstable_rowTree` param is a temporary\n   * solution to decouple the code.\n   */\n  const getRows = function () {\n    let rowParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let unstable_rowTree = arguments.length > 1 ? arguments[1] : undefined;\n    if (!rowParams.rows && !range) {\n      return [];\n    }\n    let baseRenderContext = renderContext;\n    if (rowParams.renderContext) {\n      baseRenderContext = rowParams.renderContext;\n      baseRenderContext.firstColumnIndex = renderContext.firstColumnIndex;\n      baseRenderContext.lastColumnIndex = renderContext.lastColumnIndex;\n    }\n    const isLastSection = !hasBottomPinnedRows && rowParams.position === undefined || hasBottomPinnedRows && rowParams.position === 'bottom';\n    const isPinnedSection = rowParams.position !== undefined;\n    let rowIndexOffset;\n    switch (rowParams.position) {\n      case 'top':\n        rowIndexOffset = 0;\n        break;\n      case 'bottom':\n        rowIndexOffset = pinnedRows.top.length + rows.length;\n        break;\n      case undefined:\n      default:\n        rowIndexOffset = pinnedRows.top.length;\n        break;\n    }\n    const rowModels = rowParams.rows ?? rows;\n    const firstRowToRender = baseRenderContext.firstRowIndex;\n    const lastRowToRender = Math.min(baseRenderContext.lastRowIndex, rowModels.length);\n    const rowIndexes = rowParams.rows ? createRange(0, rowParams.rows.length) : createRange(firstRowToRender, lastRowToRender);\n    let virtualRowIndex = -1;\n    const focusedVirtualCell = params.focusedVirtualCell();\n    if (!isPinnedSection && focusedVirtualCell) {\n      if (focusedVirtualCell.rowIndex < firstRowToRender) {\n        rowIndexes.unshift(focusedVirtualCell.rowIndex);\n        virtualRowIndex = focusedVirtualCell.rowIndex;\n      }\n      if (focusedVirtualCell.rowIndex > lastRowToRender) {\n        rowIndexes.push(focusedVirtualCell.rowIndex);\n        virtualRowIndex = focusedVirtualCell.rowIndex;\n      }\n    }\n    const rowElements = [];\n    const columnPositions = Dimensions.selectors.columnPositions(store.state, columns);\n    rowIndexes.forEach(rowIndexInPage => {\n      const {\n        id,\n        model\n      } = rowModels[rowIndexInPage];\n\n      // In certain cases, the state might already be updated and `params.rows` (which sets `rowModels`)\n      // contains stale data.\n      // In that case, skip any further row processing.\n      // See:\n      // - https://github.com/mui/mui-x/issues/16638\n      // - https://github.com/mui/mui-x/issues/17022\n      if (!unstable_rowTree[id]) {\n        return;\n      }\n      const rowIndex = (range?.firstRowIndex || 0) + rowIndexOffset + rowIndexInPage;\n\n      // NOTE: This is an expensive feature, the colSpan code could be optimized.\n      if (hasColSpan) {\n        const minFirstColumn = pinnedColumns.left.length;\n        const maxLastColumn = columns.length - pinnedColumns.right.length;\n        api.calculateColSpan(id, minFirstColumn, maxLastColumn, columns);\n        if (pinnedColumns.left.length > 0) {\n          api.calculateColSpan(id, 0, pinnedColumns.left.length, columns);\n        }\n        if (pinnedColumns.right.length > 0) {\n          api.calculateColSpan(id, columns.length - pinnedColumns.right.length, columns.length, columns);\n        }\n      }\n      const baseRowHeight = !api.rowsMeta.rowHasAutoHeight(id) ? api.rowsMeta.getRowHeight(id) : 'auto';\n      let isFirstVisible = false;\n      if (rowParams.position === undefined) {\n        isFirstVisible = rowIndexInPage === 0;\n      }\n      let isLastVisible = false;\n      const isLastVisibleInSection = rowIndexInPage === rowModels.length - 1;\n      if (isLastSection) {\n        if (!isPinnedSection) {\n          const lastIndex = rows.length - 1;\n          const isLastVisibleRowIndex = rowIndexInPage === lastIndex;\n          if (isLastVisibleRowIndex) {\n            isLastVisible = true;\n          }\n        } else {\n          isLastVisible = isLastVisibleInSection;\n        }\n      }\n      let currentRenderContext = baseRenderContext;\n      if (frozenContext.current && rowIndexInPage >= frozenContext.current.firstRowIndex && rowIndexInPage < frozenContext.current.lastRowIndex) {\n        currentRenderContext = frozenContext.current;\n      }\n      const isVirtualFocusRow = rowIndexInPage === virtualRowIndex;\n      const isVirtualFocusColumn = focusedVirtualCell?.rowIndex === rowIndex;\n      const offsetLeft = computeOffsetLeft(columnPositions, currentRenderContext, pinnedColumns.left.length);\n      const showBottomBorder = isLastVisibleInSection && rowParams.position === 'top';\n      const firstColumnIndex = currentRenderContext.firstColumnIndex;\n      const lastColumnIndex = currentRenderContext.lastColumnIndex;\n      rowElements.push(renderRow({\n        id,\n        model,\n        rowIndex,\n        offsetLeft,\n        columnsTotalWidth,\n        baseRowHeight,\n        columns,\n        firstColumnIndex,\n        lastColumnIndex,\n        focusedColumnIndex: isVirtualFocusColumn ? focusedVirtualCell.columnIndex : undefined,\n        isFirstVisible,\n        isLastVisible,\n        isVirtualFocusRow,\n        showBottomBorder\n      }));\n      if (isVirtualFocusRow) {\n        return;\n      }\n      const panel = panels.get(id);\n      if (panel) {\n        rowElements.push(panel);\n      }\n      if (rowParams.position === undefined && isLastVisibleInSection) {\n        rowElements.push(renderInfiniteLoadingTrigger(id));\n      }\n    });\n    return rowElements;\n  };\n  const scrollerStyle = React.useMemo(() => ({\n    overflowX: !needsHorizontalScrollbar ? 'hidden' : undefined,\n    overflowY: autoHeight ? 'hidden' : undefined\n  }), [needsHorizontalScrollbar, autoHeight]);\n  const contentSize = React.useMemo(() => {\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      flexBasis: contentHeight,\n      flexShrink: 0\n    };\n    if (size.flexBasis === 0) {\n      size.flexBasis = minimalContentHeight; // Give room to show the overlay when there no rows.\n    }\n    return size;\n  }, [columnsTotalWidth, contentHeight, needsHorizontalScrollbar, minimalContentHeight]);\n  const verticalScrollRestoreCallback = React.useRef(null);\n  const onContentSizeApplied = React.useCallback(node => {\n    if (!node) {\n      return;\n    }\n    verticalScrollRestoreCallback.current?.(columnsTotalWidth, contentHeight);\n  }, [columnsTotalWidth, contentHeight]);\n  useEnhancedEffect(() => {\n    if (!isRenderContextReady.current) {\n      return;\n    }\n    forceUpdateRenderContext();\n  }, [enabledForColumns, enabledForRows, forceUpdateRenderContext]);\n  useEnhancedEffect(() => {\n    if (refs.scroller.current) {\n      refs.scroller.current.scrollLeft = 0;\n    }\n  }, [refs.scroller, scrollReset]);\n  useRunOnce(renderContext !== EMPTY_RENDER_CONTEXT, () => {\n    onScrollChange?.(scrollPosition.current, renderContext);\n    isRenderContextReady.current = true;\n    if (initialState?.scroll && refs.scroller.current) {\n      const scroller = refs.scroller.current;\n      const {\n        top,\n        left\n      } = initialState.scroll;\n\n      // On initial mount, if we have columns available, we can restore the horizontal scroll immediately, but we need to skip the resulting scroll event, otherwise we would recalculate the render context at position top=0, left=restoredValue, but the initial render context is already calculated based on the initial value of scrollPosition ref.\n      const isScrollRestored = {\n        top: !(top > 0),\n        left: !(left > 0)\n      };\n      if (!isScrollRestored.left && columnsTotalWidth) {\n        scroller.scrollLeft = left;\n        ignoreNextScrollEvent.current = true;\n        isScrollRestored.left = true;\n      }\n\n      // For the sake of completeness, but I'm not sure if contentHeight is ever available at this point. Maybe when virtualisation is disabled?\n      if (!isScrollRestored.top && contentHeight) {\n        scroller.scrollTop = top;\n        ignoreNextScrollEvent.current = true;\n        isScrollRestored.top = true;\n      }\n\n      // To restore the vertical scroll, we need to wait until the rows are available in the DOM (otherwise there's nowhere to scroll), but before paint to avoid reflows\n      if (!isScrollRestored.top || !isScrollRestored.left) {\n        verticalScrollRestoreCallback.current = (columnsTotalWidthCurrent, contentHeightCurrent) => {\n          if (!isScrollRestored.left && columnsTotalWidthCurrent) {\n            scroller.scrollLeft = left;\n            ignoreNextScrollEvent.current = true;\n            isScrollRestored.left = true;\n          }\n          if (!isScrollRestored.top && contentHeightCurrent) {\n            scroller.scrollTop = top;\n            ignoreNextScrollEvent.current = true;\n            isScrollRestored.top = true;\n          }\n          if (isScrollRestored.left && isScrollRestored.top) {\n            verticalScrollRestoreCallback.current = null;\n          }\n        };\n      }\n    }\n  });\n  useStoreEffect(store, Dimensions.selectors.dimensions, forceUpdateRenderContext);\n  const getters = {\n    setPanels,\n    getRows,\n    getContainerProps: () => ({\n      ref: params.refs.container\n    }),\n    getScrollerProps: () => ({\n      ref: refs.scroller,\n      onScroll: handleScroll,\n      onWheel,\n      onTouchMove,\n      style: scrollerStyle,\n      role: 'presentation',\n      // `tabIndex` shouldn't be used along role=presentation, but it fixes a Firefox bug\n      // https://github.com/mui/mui-x/pull/13891#discussion_r1683416024\n      tabIndex: platform.isFirefox ? -1 : undefined\n    }),\n    getContentProps: () => ({\n      style: contentSize,\n      role: 'presentation',\n      ref: onContentSizeApplied\n    }),\n    getRenderZoneProps: () => ({\n      role: 'rowgroup'\n    }),\n    getScrollbarVerticalProps: () => ({\n      ref: refs.scrollbarVertical,\n      scrollPosition\n    }),\n    getScrollbarHorizontalProps: () => ({\n      ref: refs.scrollbarHorizontal,\n      scrollPosition\n    }),\n    getScrollAreaProps: () => ({\n      scrollPosition\n    })\n  };\n  useFirstRender(() => {\n    store.state = _extends({}, store.state, {\n      getters\n    });\n  });\n  React.useEffect(() => {\n    store.update(_extends({}, store.state, {\n      getters\n    }));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, Object.values(getters));\n\n  /* Placeholder API functions for colspan & rowspan to re-implement */\n\n  const getCellColSpanInfo = () => {\n    throw new Error('Unimplemented: colspan feature is required');\n  };\n  const calculateColSpan = () => {\n    throw new Error('Unimplemented: colspan feature is required');\n  };\n  const getHiddenCellsOrigin = () => {\n    throw new Error('Unimplemented: rowspan feature is required');\n  };\n  return {\n    getters,\n    useVirtualization: () => useStore(store, state => state),\n    setPanels,\n    forceUpdateRenderContext,\n    getCellColSpanInfo,\n    calculateColSpan,\n    getHiddenCellsOrigin\n  };\n}\nfunction inputsSelector(store, params, api, enabledForRows, enabledForColumns) {\n  const dimensions = Dimensions.selectors.dimensions(store.state);\n  const rows = params.rows;\n  const range = params.range;\n  const columns = params.columns;\n  const hiddenCellsOriginMap = api.getHiddenCellsOrigin();\n  const lastRowId = params.rows.at(-1)?.id;\n  const lastColumn = columns.at(-1);\n  return {\n    api,\n    enabledForRows,\n    enabledForColumns,\n    autoHeight: params.autoHeight,\n    rowBufferPx: params.rowBufferPx,\n    columnBufferPx: params.columnBufferPx,\n    leftPinnedWidth: dimensions.leftPinnedWidth,\n    columnsTotalWidth: dimensions.columnsTotalWidth,\n    viewportInnerWidth: dimensions.viewportInnerSize.width,\n    viewportInnerHeight: dimensions.viewportInnerSize.height,\n    lastRowHeight: lastRowId !== undefined ? api.rowsMeta.getRowHeight(lastRowId) : 0,\n    lastColumnWidth: lastColumn?.computedWidth ?? 0,\n    rowsMeta: Dimensions.selectors.rowsMeta(store.state),\n    columnPositions: Dimensions.selectors.columnPositions(store.state, params.columns),\n    rows,\n    range,\n    pinnedColumns: params.pinnedColumns,\n    columns,\n    hiddenCellsOriginMap,\n    virtualizeColumnsWithAutoRowHeight: params.virtualizeColumnsWithAutoRowHeight\n  };\n}\nfunction computeRenderContext(inputs, scrollPosition, scrollCache) {\n  const renderContext = {\n    firstRowIndex: 0,\n    lastRowIndex: inputs.rows.length,\n    firstColumnIndex: 0,\n    lastColumnIndex: inputs.columns.length\n  };\n  const {\n    top,\n    left\n  } = scrollPosition;\n  const realLeft = Math.abs(left) + inputs.leftPinnedWidth;\n  if (inputs.enabledForRows) {\n    // Clamp the value because the search may return an index out of bounds.\n    // In the last index, this is not needed because Array.slice doesn't include it.\n    let firstRowIndex = Math.min(getNearestIndexToRender(inputs, top, {\n      atStart: true,\n      lastPosition: inputs.rowsMeta.positions[inputs.rowsMeta.positions.length - 1] + inputs.lastRowHeight\n    }), inputs.rowsMeta.positions.length - 1);\n\n    // If any of the cells in the `firstRowIndex` is hidden due to an extended row span,\n    // Make sure the row from where the rowSpan is originated is visible.\n    const rowSpanHiddenCellOrigin = inputs.hiddenCellsOriginMap[firstRowIndex];\n    if (rowSpanHiddenCellOrigin) {\n      const minSpannedRowIndex = Math.min(...Object.values(rowSpanHiddenCellOrigin));\n      firstRowIndex = Math.min(firstRowIndex, minSpannedRowIndex);\n    }\n    const lastRowIndex = inputs.autoHeight ? firstRowIndex + inputs.rows.length : getNearestIndexToRender(inputs, top + inputs.viewportInnerHeight);\n    renderContext.firstRowIndex = firstRowIndex;\n    renderContext.lastRowIndex = lastRowIndex;\n  }\n\n  // XXX\n  // if (inputs.listView) {\n  //   return {\n  //     ...renderContext,\n  //     lastColumnIndex: 1,\n  //   };\n  // }\n\n  if (inputs.enabledForColumns) {\n    let firstColumnIndex = 0;\n    let lastColumnIndex = inputs.columnPositions.length;\n    let hasRowWithAutoHeight = false;\n    const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n      firstIndex: renderContext.firstRowIndex,\n      lastIndex: renderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: inputs.rows.length,\n      bufferBefore: scrollCache.buffer.rowBefore,\n      bufferAfter: scrollCache.buffer.rowAfter,\n      positions: inputs.rowsMeta.positions,\n      lastSize: inputs.lastRowHeight\n    });\n    if (!inputs.virtualizeColumnsWithAutoRowHeight) {\n      for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n        const row = inputs.rows[i];\n        hasRowWithAutoHeight = inputs.api.rowsMeta.rowHasAutoHeight(row.id);\n      }\n    }\n    if (!hasRowWithAutoHeight || inputs.virtualizeColumnsWithAutoRowHeight) {\n      firstColumnIndex = binarySearch(realLeft, inputs.columnPositions, {\n        atStart: true,\n        lastPosition: inputs.columnsTotalWidth\n      });\n      lastColumnIndex = binarySearch(realLeft + inputs.viewportInnerWidth, inputs.columnPositions);\n    }\n    renderContext.firstColumnIndex = firstColumnIndex;\n    renderContext.lastColumnIndex = lastColumnIndex;\n  }\n  const actualRenderContext = deriveRenderContext(inputs, renderContext, scrollCache);\n  return actualRenderContext;\n}\nfunction getNearestIndexToRender(inputs, offset, options) {\n  const lastMeasuredIndexRelativeToAllRows = inputs.api.rowsMeta.getLastMeasuredRowIndex();\n  let allRowsMeasured = lastMeasuredIndexRelativeToAllRows === Infinity;\n  if (inputs.range?.lastRowIndex && !allRowsMeasured) {\n    // Check if all rows in this page are already measured\n    allRowsMeasured = lastMeasuredIndexRelativeToAllRows >= inputs.range.lastRowIndex;\n  }\n  const lastMeasuredIndexRelativeToCurrentPage = clamp(lastMeasuredIndexRelativeToAllRows - (inputs.range?.firstRowIndex || 0), 0, inputs.rowsMeta.positions.length);\n  if (allRowsMeasured || inputs.rowsMeta.positions[lastMeasuredIndexRelativeToCurrentPage] >= offset) {\n    // If all rows were measured (when no row has \"auto\" as height) or all rows before the offset\n    // were measured, then use a binary search because it's faster.\n    return binarySearch(offset, inputs.rowsMeta.positions, options);\n  }\n\n  // Otherwise, use an exponential search.\n  // If rows have \"auto\" as height, their positions will be based on estimated heights.\n  // In this case, we can skip several steps until we find a position higher than the offset.\n  // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n  return exponentialSearch(offset, inputs.rowsMeta.positions, lastMeasuredIndexRelativeToCurrentPage, options);\n}\n\n/**\n * Accepts as input a raw render context (the area visible in the viewport) and adds\n * computes the actual render context based on pinned elements, buffer dimensions and\n * spanning.\n */\nfunction deriveRenderContext(inputs, nextRenderContext, scrollCache) {\n  const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstRowIndex,\n    lastIndex: nextRenderContext.lastRowIndex,\n    minFirstIndex: 0,\n    maxLastIndex: inputs.rows.length,\n    bufferBefore: scrollCache.buffer.rowBefore,\n    bufferAfter: scrollCache.buffer.rowAfter,\n    positions: inputs.rowsMeta.positions,\n    lastSize: inputs.lastRowHeight\n  });\n  const [initialFirstColumnToRender, lastColumnToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstColumnIndex,\n    lastIndex: nextRenderContext.lastColumnIndex,\n    minFirstIndex: inputs.pinnedColumns.left.length,\n    maxLastIndex: inputs.columns.length - inputs.pinnedColumns.right.length,\n    bufferBefore: scrollCache.buffer.columnBefore,\n    bufferAfter: scrollCache.buffer.columnAfter,\n    positions: inputs.columnPositions,\n    lastSize: inputs.lastColumnWidth\n  });\n  const firstColumnToRender = getFirstNonSpannedColumnToRender({\n    api: inputs.api,\n    firstColumnToRender: initialFirstColumnToRender,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows: inputs.rows\n  });\n  return {\n    firstRowIndex: firstRowToRender,\n    lastRowIndex: lastRowToRender,\n    firstColumnIndex: firstColumnToRender,\n    lastColumnIndex: lastColumnToRender\n  };\n}\n/**\n * Use binary search to avoid looping through all possible positions.\n * The `options.atStart` provides the possibility to match for the first element that\n * intersects the screen, even if said element's start position is before `offset`. In\n * other words, we search for `offset + width`.\n */\nfunction binarySearch(offset, positions) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n  let sliceStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let sliceEnd = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : positions.length;\n  if (positions.length <= 0) {\n    return -1;\n  }\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const position = positions[pivot];\n  let isBefore;\n  if (options?.atStart) {\n    const width = (pivot === positions.length - 1 ? options.lastPosition : positions[pivot + 1]) - position;\n    isBefore = offset - width < position;\n  } else {\n    isBefore = offset <= position;\n  }\n  return isBefore ? binarySearch(offset, positions, options, sliceStart, pivot) : binarySearch(offset, positions, options, pivot + 1, sliceEnd);\n}\nfunction exponentialSearch(offset, positions, index) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n  let interval = 1;\n  while (index < positions.length && Math.abs(positions[index]) < offset) {\n    index += interval;\n    interval *= 2;\n  }\n  return binarySearch(offset, positions, options, Math.floor(index / 2), Math.min(index, positions.length));\n}\nfunction getIndexesToRender(_ref) {\n  let {\n    firstIndex,\n    lastIndex,\n    bufferBefore,\n    bufferAfter,\n    minFirstIndex,\n    maxLastIndex,\n    positions,\n    lastSize\n  } = _ref;\n  const firstPosition = positions[firstIndex] - bufferBefore;\n  const lastPosition = positions[lastIndex] + bufferAfter;\n  const firstIndexPadded = binarySearch(firstPosition, positions, {\n    atStart: true,\n    lastPosition: positions[positions.length - 1] + lastSize\n  });\n  const lastIndexPadded = binarySearch(lastPosition, positions);\n  return [clamp(firstIndexPadded, minFirstIndex, maxLastIndex), clamp(lastIndexPadded, minFirstIndex, maxLastIndex)];\n}\nexport function areRenderContextsEqual(context1, context2) {\n  if (context1 === context2) {\n    return true;\n  }\n  return context1.firstRowIndex === context2.firstRowIndex && context1.lastRowIndex === context2.lastRowIndex && context1.firstColumnIndex === context2.firstColumnIndex && context1.lastColumnIndex === context2.lastColumnIndex;\n}\nexport function computeOffsetLeft(columnPositions, renderContext, pinnedLeftLength) {\n  const left = (columnPositions[renderContext.firstColumnIndex] ?? 0) - (columnPositions[pinnedLeftLength] ?? 0);\n  return Math.abs(left);\n}\nfunction directionForDelta(dx, dy) {\n  if (dx === 0 && dy === 0) {\n    return ScrollDirection.NONE;\n  }\n  /* eslint-disable */\n  if (Math.abs(dy) >= Math.abs(dx)) {\n    if (dy > 0) {\n      return ScrollDirection.DOWN;\n    } else {\n      return ScrollDirection.UP;\n    }\n  } else {\n    if (dx > 0) {\n      return ScrollDirection.RIGHT;\n    } else {\n      return ScrollDirection.LEFT;\n    }\n  }\n  /* eslint-enable */\n}\nfunction bufferForDirection(isRtl, direction, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) {\n  if (isRtl) {\n    switch (direction) {\n      case ScrollDirection.LEFT:\n        direction = ScrollDirection.RIGHT;\n        break;\n      case ScrollDirection.RIGHT:\n        direction = ScrollDirection.LEFT;\n        break;\n      default:\n    }\n  }\n  switch (direction) {\n    case ScrollDirection.NONE:\n      return {\n        rowAfter: rowBufferPx,\n        rowBefore: rowBufferPx,\n        columnAfter: columnBufferPx,\n        columnBefore: columnBufferPx\n      };\n    case ScrollDirection.LEFT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: horizontalBuffer\n      };\n    case ScrollDirection.RIGHT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: horizontalBuffer,\n        columnBefore: 0\n      };\n    case ScrollDirection.UP:\n      return {\n        rowAfter: 0,\n        rowBefore: verticalBuffer,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    case ScrollDirection.DOWN:\n      return {\n        rowAfter: verticalBuffer,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    default:\n      // eslint unable to figure out enum exhaustiveness\n      throw new Error('unreachable');\n  }\n}\nfunction createScrollCache(isRtl, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) {\n  return {\n    direction: ScrollDirection.NONE,\n    buffer: bufferForDirection(isRtl, ScrollDirection.NONE, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer)\n  };\n}\nfunction createRange(from, to) {\n  return Array.from({\n    length: to - from\n  }).map((_, i) => from + i);\n}\nfunction getFirstNonSpannedColumnToRender(_ref2) {\n  let {\n    api,\n    firstColumnToRender,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows\n  } = _ref2;\n  let firstNonSpannedColumnToRender = firstColumnToRender;\n  let foundStableColumn = false;\n\n  // Keep checking columns until we find one that's not spanned in any visible row\n  while (!foundStableColumn && firstNonSpannedColumnToRender >= 0) {\n    foundStableColumn = true;\n    for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n      const row = visibleRows[i];\n      if (row) {\n        const rowId = visibleRows[i].id;\n        const cellColSpanInfo = api.getCellColSpanInfo(rowId, firstNonSpannedColumnToRender);\n        if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan && cellColSpanInfo.leftVisibleCellIndex < firstNonSpannedColumnToRender) {\n          firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;\n          foundStableColumn = false;\n          break; // Check the new column index against the visible rows, because it might be spanned\n        }\n      }\n    }\n  }\n  return firstNonSpannedColumnToRender;\n}\nexport function roundToDecimalPlaces(value, decimals) {\n  return Math.round(value * 10 ** decimals) / 10 ** decimals;\n}","map":{"version":3,"names":["_extends","React","ReactDOM","useLazyRef","useTimeout","useEventCallback","useEnhancedEffect","platform","useRunOnce","useFirstRender","createSelector","useStore","useStoreEffect","Dimensions","ScrollDirection","clamp","value","min","max","Math","MINIMUM_COLUMN_WIDTH","EMPTY_SCROLL_POSITION","top","left","EMPTY_DETAIL_PANELS","Object","freeze","Map","EMPTY_RENDER_CONTEXT","firstRowIndex","lastRowIndex","firstColumnIndex","lastColumnIndex","selectors","renderContext","state","virtualization","enabledForRows","enabledForColumns","Virtualization","initialize","initializeState","use","useVirtualization","params","enabled","isJSDOM","initialState","getters","store","api","isRtl","rows","range","columns","pinnedRows","pinnedColumns","refs","hasColSpan","dimensions","rowHeight","columnsTotalWidth","contentHeight","minimalContentHeight","autoHeight","onWheel","onTouchMove","onRenderContextChange","onScrollChange","rowBufferPx","columnBufferPx","scrollReset","renderRow","renderInfiniteLoadingTrigger","needsHorizontalScrollbar","hasBottomPinnedRows","bottom","length","panels","setPanels","useState","isRenderContextReady","useRef","scrollPosition","scroll","ignoreNextScrollEvent","previousContextScrollPosition","previousRowContext","scrollTimeout","frozenContext","undefined","scrollCache","createScrollCache","current","updateRenderContext","useCallback","nextRenderContext","areRenderContextsEqual","didRowsIntervalChange","set","isReady","triggerUpdateRenderContext","scroller","maxScrollTop","ceil","minimumSize","height","viewportOuterSize","maxScrollLeft","width","viewportInnerSize","newScroll","scrollTop","scrollLeft","dx","dy","isScrolling","direction","directionForDelta","NONE","rowScroll","abs","columnScroll","didCrossThreshold","didChangeDirection","shouldUpdate","LEFT","RIGHT","buffer","bufferForDirection","inputs","inputsSelector","computeRenderContext","flushSync","start","forceUpdateRenderContext","handleScroll","getRows","rowParams","arguments","unstable_rowTree","baseRenderContext","isLastSection","position","isPinnedSection","rowIndexOffset","rowModels","firstRowToRender","lastRowToRender","rowIndexes","createRange","virtualRowIndex","focusedVirtualCell","rowIndex","unshift","push","rowElements","columnPositions","forEach","rowIndexInPage","id","model","minFirstColumn","maxLastColumn","right","calculateColSpan","baseRowHeight","rowsMeta","rowHasAutoHeight","getRowHeight","isFirstVisible","isLastVisible","isLastVisibleInSection","lastIndex","isLastVisibleRowIndex","currentRenderContext","isVirtualFocusRow","isVirtualFocusColumn","offsetLeft","computeOffsetLeft","showBottomBorder","focusedColumnIndex","columnIndex","panel","get","scrollerStyle","useMemo","overflowX","overflowY","contentSize","size","flexBasis","flexShrink","verticalScrollRestoreCallback","onContentSizeApplied","node","isScrollRestored","columnsTotalWidthCurrent","contentHeightCurrent","getContainerProps","ref","container","getScrollerProps","onScroll","style","role","tabIndex","isFirefox","getContentProps","getRenderZoneProps","getScrollbarVerticalProps","scrollbarVertical","getScrollbarHorizontalProps","scrollbarHorizontal","getScrollAreaProps","useEffect","update","values","getCellColSpanInfo","Error","getHiddenCellsOrigin","hiddenCellsOriginMap","lastRowId","at","lastColumn","leftPinnedWidth","viewportInnerWidth","viewportInnerHeight","lastRowHeight","lastColumnWidth","computedWidth","virtualizeColumnsWithAutoRowHeight","realLeft","getNearestIndexToRender","atStart","lastPosition","positions","rowSpanHiddenCellOrigin","minSpannedRowIndex","hasRowWithAutoHeight","getIndexesToRender","firstIndex","minFirstIndex","maxLastIndex","bufferBefore","rowBefore","bufferAfter","rowAfter","lastSize","i","row","binarySearch","actualRenderContext","deriveRenderContext","offset","options","lastMeasuredIndexRelativeToAllRows","getLastMeasuredRowIndex","allRowsMeasured","Infinity","lastMeasuredIndexRelativeToCurrentPage","exponentialSearch","initialFirstColumnToRender","lastColumnToRender","columnBefore","columnAfter","firstColumnToRender","getFirstNonSpannedColumnToRender","visibleRows","sliceStart","sliceEnd","pivot","floor","isBefore","index","interval","_ref","firstPosition","firstIndexPadded","lastIndexPadded","context1","context2","pinnedLeftLength","DOWN","UP","verticalBuffer","horizontalBuffer","from","to","Array","map","_","_ref2","firstNonSpannedColumnToRender","foundStableColumn","rowId","cellColSpanInfo","spannedByColSpan","leftVisibleCellIndex","roundToDecimalPlaces","decimals","round"],"sources":["C:/Users/mis/rbt-dashboard/node_modules/@mui/x-virtualizer/esm/features/virtualization.js"],"sourcesContent":["'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport useLazyRef from '@mui/utils/useLazyRef';\nimport useTimeout from '@mui/utils/useTimeout';\nimport useEventCallback from '@mui/utils/useEventCallback';\nimport useEnhancedEffect from '@mui/utils/useEnhancedEffect';\nimport * as platform from '@mui/x-internals/platform';\nimport { useRunOnce } from '@mui/x-internals/useRunOnce';\nimport { useFirstRender } from '@mui/x-internals/useFirstRender';\nimport { createSelector, useStore, useStoreEffect } from '@mui/x-internals/store';\nimport { Dimensions } from \"./dimensions.js\";\nimport { ScrollDirection } from \"../models/index.js\";\n\n/* eslint-disable import/export, @typescript-eslint/no-redeclare */\n\nconst clamp = (value, min, max) => Math.max(min, Math.min(max, value));\nconst MINIMUM_COLUMN_WIDTH = 50;\nconst EMPTY_SCROLL_POSITION = {\n  top: 0,\n  left: 0\n};\nconst EMPTY_DETAIL_PANELS = Object.freeze(new Map());\nexport const EMPTY_RENDER_CONTEXT = {\n  firstRowIndex: 0,\n  lastRowIndex: 0,\n  firstColumnIndex: 0,\n  lastColumnIndex: 0\n};\nconst selectors = {\n  renderContext: createSelector(state => state.virtualization.renderContext),\n  enabledForRows: createSelector(state => state.virtualization.enabledForRows),\n  enabledForColumns: createSelector(state => state.virtualization.enabledForColumns)\n};\nexport const Virtualization = {\n  initialize: initializeState,\n  use: useVirtualization,\n  selectors\n};\nfunction initializeState(params) {\n  const state = {\n    virtualization: _extends({\n      enabled: !platform.isJSDOM,\n      enabledForRows: !platform.isJSDOM,\n      enabledForColumns: !platform.isJSDOM,\n      renderContext: EMPTY_RENDER_CONTEXT\n    }, params.initialState?.virtualization),\n    // FIXME: refactor once the state shape is settled\n    getters: null\n  };\n  return state;\n}\n\n/** APIs to override for colspan/rowspan */\n\nfunction useVirtualization(store, params, api) {\n  const {\n    initialState,\n    isRtl,\n    rows,\n    range,\n    columns,\n    pinnedRows,\n    pinnedColumns,\n    refs,\n    hasColSpan,\n    dimensions: {\n      rowHeight,\n      columnsTotalWidth\n    },\n    contentHeight,\n    minimalContentHeight,\n    autoHeight,\n    onWheel,\n    onTouchMove,\n    onRenderContextChange,\n    onScrollChange,\n    rowBufferPx,\n    columnBufferPx,\n    scrollReset,\n    renderRow,\n    renderInfiniteLoadingTrigger\n  } = params;\n  const needsHorizontalScrollbar = useStore(store, Dimensions.selectors.needsHorizontalScrollbar);\n  const hasBottomPinnedRows = pinnedRows.bottom.length > 0;\n  const [panels, setPanels] = React.useState(EMPTY_DETAIL_PANELS);\n  const isRenderContextReady = React.useRef(false);\n  const renderContext = useStore(store, selectors.renderContext);\n  const enabledForRows = useStore(store, selectors.enabledForRows);\n  const enabledForColumns = useStore(store, selectors.enabledForColumns);\n\n  /*\n   * Scroll context logic\n   * ====================\n   * We only render the cells contained in the `renderContext`. However, when the user starts scrolling the grid\n   * in a direction, we want to render as many cells as possible in that direction, as to avoid presenting white\n   * areas if the user scrolls too fast/far and the viewport ends up in a region we haven't rendered yet. To render\n   * more cells, we store some offsets to add to the viewport in `scrollCache.buffer`. Those offsets make the render\n   * context wider in the direction the user is going, but also makes the buffer around the viewport `0` for the\n   * dimension (horizontal or vertical) in which the user is not scrolling. So if the normal viewport is 8 columns\n   * wide, with a 1 column buffer (10 columns total), then we want it to be exactly 8 columns wide during vertical\n   * scroll.\n   * However, we don't want the rows in the old context to re-render from e.g. 10 columns to 8 columns, because that's\n   * work that's not necessary. Thus we store the context at the start of the scroll in `frozenContext`, and the rows\n   * that are part of this old context will keep their same render context as to avoid re-rendering.\n   */\n  const scrollPosition = React.useRef(initialState?.scroll ?? EMPTY_SCROLL_POSITION);\n  const ignoreNextScrollEvent = React.useRef(false);\n  const previousContextScrollPosition = React.useRef(EMPTY_SCROLL_POSITION);\n  const previousRowContext = React.useRef(EMPTY_RENDER_CONTEXT);\n  const scrollTimeout = useTimeout();\n  const frozenContext = React.useRef(undefined);\n  const scrollCache = useLazyRef(() => createScrollCache(isRtl, rowBufferPx, columnBufferPx, rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6)).current;\n  const updateRenderContext = React.useCallback(nextRenderContext => {\n    if (areRenderContextsEqual(nextRenderContext, store.state.virtualization.renderContext)) {\n      return;\n    }\n    const didRowsIntervalChange = nextRenderContext.firstRowIndex !== previousRowContext.current.firstRowIndex || nextRenderContext.lastRowIndex !== previousRowContext.current.lastRowIndex;\n    store.set('virtualization', _extends({}, store.state.virtualization, {\n      renderContext: nextRenderContext\n    }));\n\n    // The lazy-loading hook is listening to `renderedRowsIntervalChange`,\n    // but only does something if we already have a render context, because\n    // otherwise we would call an update directly on mount\n    const isReady = Dimensions.selectors.dimensions(store.state).isReady;\n    if (isReady && didRowsIntervalChange) {\n      previousRowContext.current = nextRenderContext;\n      onRenderContextChange?.(nextRenderContext);\n    }\n    previousContextScrollPosition.current = scrollPosition.current;\n  }, [store, onRenderContextChange]);\n  const triggerUpdateRenderContext = useEventCallback(() => {\n    const scroller = refs.scroller.current;\n    if (!scroller) {\n      return undefined;\n    }\n    const dimensions = Dimensions.selectors.dimensions(store.state);\n    const maxScrollTop = Math.ceil(dimensions.minimumSize.height - dimensions.viewportOuterSize.height);\n    const maxScrollLeft = Math.ceil(dimensions.minimumSize.width - dimensions.viewportInnerSize.width);\n\n    // Clamp the scroll position to the viewport to avoid re-calculating the render context for scroll bounce\n    const newScroll = {\n      top: clamp(scroller.scrollTop, 0, maxScrollTop),\n      left: isRtl ? clamp(scroller.scrollLeft, -maxScrollLeft, 0) : clamp(scroller.scrollLeft, 0, maxScrollLeft)\n    };\n    const dx = newScroll.left - scrollPosition.current.left;\n    const dy = newScroll.top - scrollPosition.current.top;\n    const isScrolling = dx !== 0 || dy !== 0;\n    scrollPosition.current = newScroll;\n    const direction = isScrolling ? directionForDelta(dx, dy) : ScrollDirection.NONE;\n\n    // Since previous render, we have scrolled...\n    const rowScroll = Math.abs(scrollPosition.current.top - previousContextScrollPosition.current.top);\n    const columnScroll = Math.abs(scrollPosition.current.left - previousContextScrollPosition.current.left);\n\n    // PERF: use the computed minimum column width instead of a static one\n    const didCrossThreshold = rowScroll >= rowHeight || columnScroll >= MINIMUM_COLUMN_WIDTH;\n    const didChangeDirection = scrollCache.direction !== direction;\n    const shouldUpdate = didCrossThreshold || didChangeDirection;\n    if (!shouldUpdate) {\n      return renderContext;\n    }\n\n    // Render a new context\n\n    if (didChangeDirection) {\n      switch (direction) {\n        case ScrollDirection.NONE:\n        case ScrollDirection.LEFT:\n        case ScrollDirection.RIGHT:\n          frozenContext.current = undefined;\n          break;\n        default:\n          frozenContext.current = renderContext;\n          break;\n      }\n    }\n    scrollCache.direction = direction;\n    scrollCache.buffer = bufferForDirection(isRtl, direction, rowBufferPx, columnBufferPx, rowHeight * 15, MINIMUM_COLUMN_WIDTH * 6);\n    const inputs = inputsSelector(store, params, api, enabledForRows, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    if (!areRenderContextsEqual(nextRenderContext, renderContext)) {\n      // Prevents batching render context changes\n      ReactDOM.flushSync(() => {\n        updateRenderContext(nextRenderContext);\n      });\n      scrollTimeout.start(1000, triggerUpdateRenderContext);\n    }\n    return nextRenderContext;\n  });\n  const forceUpdateRenderContext = useEventCallback(() => {\n    // skip update if dimensions are not ready and virtualization is enabled\n    if (!Dimensions.selectors.dimensions(store.state).isReady && (enabledForRows || enabledForColumns)) {\n      return;\n    }\n    const inputs = inputsSelector(store, params, api, enabledForRows, enabledForColumns);\n    const nextRenderContext = computeRenderContext(inputs, scrollPosition.current, scrollCache);\n    // Reset the frozen context when the render context changes, see the illustration in https://github.com/mui/mui-x/pull/12353\n    frozenContext.current = undefined;\n    updateRenderContext(nextRenderContext);\n  });\n  const handleScroll = useEventCallback(() => {\n    if (ignoreNextScrollEvent.current) {\n      ignoreNextScrollEvent.current = false;\n      return;\n    }\n    const nextRenderContext = triggerUpdateRenderContext();\n    if (nextRenderContext) {\n      onScrollChange?.(scrollPosition.current, nextRenderContext);\n    }\n  });\n\n  /**\n   * HACK: unstable_rowTree fixes the issue described below, but does it by tightly coupling this\n   * section of code to the DataGrid's rowTree model. The `unstable_rowTree` param is a temporary\n   * solution to decouple the code.\n   */\n  const getRows = (\n  // eslint-disable-next-line @typescript-eslint/default-param-last\n  rowParams = {}, unstable_rowTree) => {\n    if (!rowParams.rows && !range) {\n      return [];\n    }\n    let baseRenderContext = renderContext;\n    if (rowParams.renderContext) {\n      baseRenderContext = rowParams.renderContext;\n      baseRenderContext.firstColumnIndex = renderContext.firstColumnIndex;\n      baseRenderContext.lastColumnIndex = renderContext.lastColumnIndex;\n    }\n    const isLastSection = !hasBottomPinnedRows && rowParams.position === undefined || hasBottomPinnedRows && rowParams.position === 'bottom';\n    const isPinnedSection = rowParams.position !== undefined;\n    let rowIndexOffset;\n    switch (rowParams.position) {\n      case 'top':\n        rowIndexOffset = 0;\n        break;\n      case 'bottom':\n        rowIndexOffset = pinnedRows.top.length + rows.length;\n        break;\n      case undefined:\n      default:\n        rowIndexOffset = pinnedRows.top.length;\n        break;\n    }\n    const rowModels = rowParams.rows ?? rows;\n    const firstRowToRender = baseRenderContext.firstRowIndex;\n    const lastRowToRender = Math.min(baseRenderContext.lastRowIndex, rowModels.length);\n    const rowIndexes = rowParams.rows ? createRange(0, rowParams.rows.length) : createRange(firstRowToRender, lastRowToRender);\n    let virtualRowIndex = -1;\n    const focusedVirtualCell = params.focusedVirtualCell();\n    if (!isPinnedSection && focusedVirtualCell) {\n      if (focusedVirtualCell.rowIndex < firstRowToRender) {\n        rowIndexes.unshift(focusedVirtualCell.rowIndex);\n        virtualRowIndex = focusedVirtualCell.rowIndex;\n      }\n      if (focusedVirtualCell.rowIndex > lastRowToRender) {\n        rowIndexes.push(focusedVirtualCell.rowIndex);\n        virtualRowIndex = focusedVirtualCell.rowIndex;\n      }\n    }\n    const rowElements = [];\n    const columnPositions = Dimensions.selectors.columnPositions(store.state, columns);\n    rowIndexes.forEach(rowIndexInPage => {\n      const {\n        id,\n        model\n      } = rowModels[rowIndexInPage];\n\n      // In certain cases, the state might already be updated and `params.rows` (which sets `rowModels`)\n      // contains stale data.\n      // In that case, skip any further row processing.\n      // See:\n      // - https://github.com/mui/mui-x/issues/16638\n      // - https://github.com/mui/mui-x/issues/17022\n      if (!unstable_rowTree[id]) {\n        return;\n      }\n      const rowIndex = (range?.firstRowIndex || 0) + rowIndexOffset + rowIndexInPage;\n\n      // NOTE: This is an expensive feature, the colSpan code could be optimized.\n      if (hasColSpan) {\n        const minFirstColumn = pinnedColumns.left.length;\n        const maxLastColumn = columns.length - pinnedColumns.right.length;\n        api.calculateColSpan(id, minFirstColumn, maxLastColumn, columns);\n        if (pinnedColumns.left.length > 0) {\n          api.calculateColSpan(id, 0, pinnedColumns.left.length, columns);\n        }\n        if (pinnedColumns.right.length > 0) {\n          api.calculateColSpan(id, columns.length - pinnedColumns.right.length, columns.length, columns);\n        }\n      }\n      const baseRowHeight = !api.rowsMeta.rowHasAutoHeight(id) ? api.rowsMeta.getRowHeight(id) : 'auto';\n      let isFirstVisible = false;\n      if (rowParams.position === undefined) {\n        isFirstVisible = rowIndexInPage === 0;\n      }\n      let isLastVisible = false;\n      const isLastVisibleInSection = rowIndexInPage === rowModels.length - 1;\n      if (isLastSection) {\n        if (!isPinnedSection) {\n          const lastIndex = rows.length - 1;\n          const isLastVisibleRowIndex = rowIndexInPage === lastIndex;\n          if (isLastVisibleRowIndex) {\n            isLastVisible = true;\n          }\n        } else {\n          isLastVisible = isLastVisibleInSection;\n        }\n      }\n      let currentRenderContext = baseRenderContext;\n      if (frozenContext.current && rowIndexInPage >= frozenContext.current.firstRowIndex && rowIndexInPage < frozenContext.current.lastRowIndex) {\n        currentRenderContext = frozenContext.current;\n      }\n      const isVirtualFocusRow = rowIndexInPage === virtualRowIndex;\n      const isVirtualFocusColumn = focusedVirtualCell?.rowIndex === rowIndex;\n      const offsetLeft = computeOffsetLeft(columnPositions, currentRenderContext, pinnedColumns.left.length);\n      const showBottomBorder = isLastVisibleInSection && rowParams.position === 'top';\n      const firstColumnIndex = currentRenderContext.firstColumnIndex;\n      const lastColumnIndex = currentRenderContext.lastColumnIndex;\n      rowElements.push(renderRow({\n        id,\n        model,\n        rowIndex,\n        offsetLeft,\n        columnsTotalWidth,\n        baseRowHeight,\n        columns,\n        firstColumnIndex,\n        lastColumnIndex,\n        focusedColumnIndex: isVirtualFocusColumn ? focusedVirtualCell.columnIndex : undefined,\n        isFirstVisible,\n        isLastVisible,\n        isVirtualFocusRow,\n        showBottomBorder\n      }));\n      if (isVirtualFocusRow) {\n        return;\n      }\n      const panel = panels.get(id);\n      if (panel) {\n        rowElements.push(panel);\n      }\n      if (rowParams.position === undefined && isLastVisibleInSection) {\n        rowElements.push(renderInfiniteLoadingTrigger(id));\n      }\n    });\n    return rowElements;\n  };\n  const scrollerStyle = React.useMemo(() => ({\n    overflowX: !needsHorizontalScrollbar ? 'hidden' : undefined,\n    overflowY: autoHeight ? 'hidden' : undefined\n  }), [needsHorizontalScrollbar, autoHeight]);\n  const contentSize = React.useMemo(() => {\n    const size = {\n      width: needsHorizontalScrollbar ? columnsTotalWidth : 'auto',\n      flexBasis: contentHeight,\n      flexShrink: 0\n    };\n    if (size.flexBasis === 0) {\n      size.flexBasis = minimalContentHeight; // Give room to show the overlay when there no rows.\n    }\n    return size;\n  }, [columnsTotalWidth, contentHeight, needsHorizontalScrollbar, minimalContentHeight]);\n  const verticalScrollRestoreCallback = React.useRef(null);\n  const onContentSizeApplied = React.useCallback(node => {\n    if (!node) {\n      return;\n    }\n    verticalScrollRestoreCallback.current?.(columnsTotalWidth, contentHeight);\n  }, [columnsTotalWidth, contentHeight]);\n  useEnhancedEffect(() => {\n    if (!isRenderContextReady.current) {\n      return;\n    }\n    forceUpdateRenderContext();\n  }, [enabledForColumns, enabledForRows, forceUpdateRenderContext]);\n  useEnhancedEffect(() => {\n    if (refs.scroller.current) {\n      refs.scroller.current.scrollLeft = 0;\n    }\n  }, [refs.scroller, scrollReset]);\n  useRunOnce(renderContext !== EMPTY_RENDER_CONTEXT, () => {\n    onScrollChange?.(scrollPosition.current, renderContext);\n    isRenderContextReady.current = true;\n    if (initialState?.scroll && refs.scroller.current) {\n      const scroller = refs.scroller.current;\n      const {\n        top,\n        left\n      } = initialState.scroll;\n\n      // On initial mount, if we have columns available, we can restore the horizontal scroll immediately, but we need to skip the resulting scroll event, otherwise we would recalculate the render context at position top=0, left=restoredValue, but the initial render context is already calculated based on the initial value of scrollPosition ref.\n      const isScrollRestored = {\n        top: !(top > 0),\n        left: !(left > 0)\n      };\n      if (!isScrollRestored.left && columnsTotalWidth) {\n        scroller.scrollLeft = left;\n        ignoreNextScrollEvent.current = true;\n        isScrollRestored.left = true;\n      }\n\n      // For the sake of completeness, but I'm not sure if contentHeight is ever available at this point. Maybe when virtualisation is disabled?\n      if (!isScrollRestored.top && contentHeight) {\n        scroller.scrollTop = top;\n        ignoreNextScrollEvent.current = true;\n        isScrollRestored.top = true;\n      }\n\n      // To restore the vertical scroll, we need to wait until the rows are available in the DOM (otherwise there's nowhere to scroll), but before paint to avoid reflows\n      if (!isScrollRestored.top || !isScrollRestored.left) {\n        verticalScrollRestoreCallback.current = (columnsTotalWidthCurrent, contentHeightCurrent) => {\n          if (!isScrollRestored.left && columnsTotalWidthCurrent) {\n            scroller.scrollLeft = left;\n            ignoreNextScrollEvent.current = true;\n            isScrollRestored.left = true;\n          }\n          if (!isScrollRestored.top && contentHeightCurrent) {\n            scroller.scrollTop = top;\n            ignoreNextScrollEvent.current = true;\n            isScrollRestored.top = true;\n          }\n          if (isScrollRestored.left && isScrollRestored.top) {\n            verticalScrollRestoreCallback.current = null;\n          }\n        };\n      }\n    }\n  });\n  useStoreEffect(store, Dimensions.selectors.dimensions, forceUpdateRenderContext);\n  const getters = {\n    setPanels,\n    getRows,\n    getContainerProps: () => ({\n      ref: params.refs.container\n    }),\n    getScrollerProps: () => ({\n      ref: refs.scroller,\n      onScroll: handleScroll,\n      onWheel,\n      onTouchMove,\n      style: scrollerStyle,\n      role: 'presentation',\n      // `tabIndex` shouldn't be used along role=presentation, but it fixes a Firefox bug\n      // https://github.com/mui/mui-x/pull/13891#discussion_r1683416024\n      tabIndex: platform.isFirefox ? -1 : undefined\n    }),\n    getContentProps: () => ({\n      style: contentSize,\n      role: 'presentation',\n      ref: onContentSizeApplied\n    }),\n    getRenderZoneProps: () => ({\n      role: 'rowgroup'\n    }),\n    getScrollbarVerticalProps: () => ({\n      ref: refs.scrollbarVertical,\n      scrollPosition\n    }),\n    getScrollbarHorizontalProps: () => ({\n      ref: refs.scrollbarHorizontal,\n      scrollPosition\n    }),\n    getScrollAreaProps: () => ({\n      scrollPosition\n    })\n  };\n  useFirstRender(() => {\n    store.state = _extends({}, store.state, {\n      getters\n    });\n  });\n  React.useEffect(() => {\n    store.update(_extends({}, store.state, {\n      getters\n    }));\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, Object.values(getters));\n\n  /* Placeholder API functions for colspan & rowspan to re-implement */\n\n  const getCellColSpanInfo = () => {\n    throw new Error('Unimplemented: colspan feature is required');\n  };\n  const calculateColSpan = () => {\n    throw new Error('Unimplemented: colspan feature is required');\n  };\n  const getHiddenCellsOrigin = () => {\n    throw new Error('Unimplemented: rowspan feature is required');\n  };\n  return {\n    getters,\n    useVirtualization: () => useStore(store, state => state),\n    setPanels,\n    forceUpdateRenderContext,\n    getCellColSpanInfo,\n    calculateColSpan,\n    getHiddenCellsOrigin\n  };\n}\nfunction inputsSelector(store, params, api, enabledForRows, enabledForColumns) {\n  const dimensions = Dimensions.selectors.dimensions(store.state);\n  const rows = params.rows;\n  const range = params.range;\n  const columns = params.columns;\n  const hiddenCellsOriginMap = api.getHiddenCellsOrigin();\n  const lastRowId = params.rows.at(-1)?.id;\n  const lastColumn = columns.at(-1);\n  return {\n    api,\n    enabledForRows,\n    enabledForColumns,\n    autoHeight: params.autoHeight,\n    rowBufferPx: params.rowBufferPx,\n    columnBufferPx: params.columnBufferPx,\n    leftPinnedWidth: dimensions.leftPinnedWidth,\n    columnsTotalWidth: dimensions.columnsTotalWidth,\n    viewportInnerWidth: dimensions.viewportInnerSize.width,\n    viewportInnerHeight: dimensions.viewportInnerSize.height,\n    lastRowHeight: lastRowId !== undefined ? api.rowsMeta.getRowHeight(lastRowId) : 0,\n    lastColumnWidth: lastColumn?.computedWidth ?? 0,\n    rowsMeta: Dimensions.selectors.rowsMeta(store.state),\n    columnPositions: Dimensions.selectors.columnPositions(store.state, params.columns),\n    rows,\n    range,\n    pinnedColumns: params.pinnedColumns,\n    columns,\n    hiddenCellsOriginMap,\n    virtualizeColumnsWithAutoRowHeight: params.virtualizeColumnsWithAutoRowHeight\n  };\n}\nfunction computeRenderContext(inputs, scrollPosition, scrollCache) {\n  const renderContext = {\n    firstRowIndex: 0,\n    lastRowIndex: inputs.rows.length,\n    firstColumnIndex: 0,\n    lastColumnIndex: inputs.columns.length\n  };\n  const {\n    top,\n    left\n  } = scrollPosition;\n  const realLeft = Math.abs(left) + inputs.leftPinnedWidth;\n  if (inputs.enabledForRows) {\n    // Clamp the value because the search may return an index out of bounds.\n    // In the last index, this is not needed because Array.slice doesn't include it.\n    let firstRowIndex = Math.min(getNearestIndexToRender(inputs, top, {\n      atStart: true,\n      lastPosition: inputs.rowsMeta.positions[inputs.rowsMeta.positions.length - 1] + inputs.lastRowHeight\n    }), inputs.rowsMeta.positions.length - 1);\n\n    // If any of the cells in the `firstRowIndex` is hidden due to an extended row span,\n    // Make sure the row from where the rowSpan is originated is visible.\n    const rowSpanHiddenCellOrigin = inputs.hiddenCellsOriginMap[firstRowIndex];\n    if (rowSpanHiddenCellOrigin) {\n      const minSpannedRowIndex = Math.min(...Object.values(rowSpanHiddenCellOrigin));\n      firstRowIndex = Math.min(firstRowIndex, minSpannedRowIndex);\n    }\n    const lastRowIndex = inputs.autoHeight ? firstRowIndex + inputs.rows.length : getNearestIndexToRender(inputs, top + inputs.viewportInnerHeight);\n    renderContext.firstRowIndex = firstRowIndex;\n    renderContext.lastRowIndex = lastRowIndex;\n  }\n\n  // XXX\n  // if (inputs.listView) {\n  //   return {\n  //     ...renderContext,\n  //     lastColumnIndex: 1,\n  //   };\n  // }\n\n  if (inputs.enabledForColumns) {\n    let firstColumnIndex = 0;\n    let lastColumnIndex = inputs.columnPositions.length;\n    let hasRowWithAutoHeight = false;\n    const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n      firstIndex: renderContext.firstRowIndex,\n      lastIndex: renderContext.lastRowIndex,\n      minFirstIndex: 0,\n      maxLastIndex: inputs.rows.length,\n      bufferBefore: scrollCache.buffer.rowBefore,\n      bufferAfter: scrollCache.buffer.rowAfter,\n      positions: inputs.rowsMeta.positions,\n      lastSize: inputs.lastRowHeight\n    });\n    if (!inputs.virtualizeColumnsWithAutoRowHeight) {\n      for (let i = firstRowToRender; i < lastRowToRender && !hasRowWithAutoHeight; i += 1) {\n        const row = inputs.rows[i];\n        hasRowWithAutoHeight = inputs.api.rowsMeta.rowHasAutoHeight(row.id);\n      }\n    }\n    if (!hasRowWithAutoHeight || inputs.virtualizeColumnsWithAutoRowHeight) {\n      firstColumnIndex = binarySearch(realLeft, inputs.columnPositions, {\n        atStart: true,\n        lastPosition: inputs.columnsTotalWidth\n      });\n      lastColumnIndex = binarySearch(realLeft + inputs.viewportInnerWidth, inputs.columnPositions);\n    }\n    renderContext.firstColumnIndex = firstColumnIndex;\n    renderContext.lastColumnIndex = lastColumnIndex;\n  }\n  const actualRenderContext = deriveRenderContext(inputs, renderContext, scrollCache);\n  return actualRenderContext;\n}\nfunction getNearestIndexToRender(inputs, offset, options) {\n  const lastMeasuredIndexRelativeToAllRows = inputs.api.rowsMeta.getLastMeasuredRowIndex();\n  let allRowsMeasured = lastMeasuredIndexRelativeToAllRows === Infinity;\n  if (inputs.range?.lastRowIndex && !allRowsMeasured) {\n    // Check if all rows in this page are already measured\n    allRowsMeasured = lastMeasuredIndexRelativeToAllRows >= inputs.range.lastRowIndex;\n  }\n  const lastMeasuredIndexRelativeToCurrentPage = clamp(lastMeasuredIndexRelativeToAllRows - (inputs.range?.firstRowIndex || 0), 0, inputs.rowsMeta.positions.length);\n  if (allRowsMeasured || inputs.rowsMeta.positions[lastMeasuredIndexRelativeToCurrentPage] >= offset) {\n    // If all rows were measured (when no row has \"auto\" as height) or all rows before the offset\n    // were measured, then use a binary search because it's faster.\n    return binarySearch(offset, inputs.rowsMeta.positions, options);\n  }\n\n  // Otherwise, use an exponential search.\n  // If rows have \"auto\" as height, their positions will be based on estimated heights.\n  // In this case, we can skip several steps until we find a position higher than the offset.\n  // Inspired by https://github.com/bvaughn/react-virtualized/blob/master/source/Grid/utils/CellSizeAndPositionManager.js\n  return exponentialSearch(offset, inputs.rowsMeta.positions, lastMeasuredIndexRelativeToCurrentPage, options);\n}\n\n/**\n * Accepts as input a raw render context (the area visible in the viewport) and adds\n * computes the actual render context based on pinned elements, buffer dimensions and\n * spanning.\n */\nfunction deriveRenderContext(inputs, nextRenderContext, scrollCache) {\n  const [firstRowToRender, lastRowToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstRowIndex,\n    lastIndex: nextRenderContext.lastRowIndex,\n    minFirstIndex: 0,\n    maxLastIndex: inputs.rows.length,\n    bufferBefore: scrollCache.buffer.rowBefore,\n    bufferAfter: scrollCache.buffer.rowAfter,\n    positions: inputs.rowsMeta.positions,\n    lastSize: inputs.lastRowHeight\n  });\n  const [initialFirstColumnToRender, lastColumnToRender] = getIndexesToRender({\n    firstIndex: nextRenderContext.firstColumnIndex,\n    lastIndex: nextRenderContext.lastColumnIndex,\n    minFirstIndex: inputs.pinnedColumns.left.length,\n    maxLastIndex: inputs.columns.length - inputs.pinnedColumns.right.length,\n    bufferBefore: scrollCache.buffer.columnBefore,\n    bufferAfter: scrollCache.buffer.columnAfter,\n    positions: inputs.columnPositions,\n    lastSize: inputs.lastColumnWidth\n  });\n  const firstColumnToRender = getFirstNonSpannedColumnToRender({\n    api: inputs.api,\n    firstColumnToRender: initialFirstColumnToRender,\n    firstRowToRender,\n    lastRowToRender,\n    visibleRows: inputs.rows\n  });\n  return {\n    firstRowIndex: firstRowToRender,\n    lastRowIndex: lastRowToRender,\n    firstColumnIndex: firstColumnToRender,\n    lastColumnIndex: lastColumnToRender\n  };\n}\n/**\n * Use binary search to avoid looping through all possible positions.\n * The `options.atStart` provides the possibility to match for the first element that\n * intersects the screen, even if said element's start position is before `offset`. In\n * other words, we search for `offset + width`.\n */\nfunction binarySearch(offset, positions, options = undefined, sliceStart = 0, sliceEnd = positions.length) {\n  if (positions.length <= 0) {\n    return -1;\n  }\n  if (sliceStart >= sliceEnd) {\n    return sliceStart;\n  }\n  const pivot = sliceStart + Math.floor((sliceEnd - sliceStart) / 2);\n  const position = positions[pivot];\n  let isBefore;\n  if (options?.atStart) {\n    const width = (pivot === positions.length - 1 ? options.lastPosition : positions[pivot + 1]) - position;\n    isBefore = offset - width < position;\n  } else {\n    isBefore = offset <= position;\n  }\n  return isBefore ? binarySearch(offset, positions, options, sliceStart, pivot) : binarySearch(offset, positions, options, pivot + 1, sliceEnd);\n}\nfunction exponentialSearch(offset, positions, index, options = undefined) {\n  let interval = 1;\n  while (index < positions.length && Math.abs(positions[index]) < offset) {\n    index += interval;\n    interval *= 2;\n  }\n  return binarySearch(offset, positions, options, Math.floor(index / 2), Math.min(index, positions.length));\n}\nfunction getIndexesToRender({\n  firstIndex,\n  lastIndex,\n  bufferBefore,\n  bufferAfter,\n  minFirstIndex,\n  maxLastIndex,\n  positions,\n  lastSize\n}) {\n  const firstPosition = positions[firstIndex] - bufferBefore;\n  const lastPosition = positions[lastIndex] + bufferAfter;\n  const firstIndexPadded = binarySearch(firstPosition, positions, {\n    atStart: true,\n    lastPosition: positions[positions.length - 1] + lastSize\n  });\n  const lastIndexPadded = binarySearch(lastPosition, positions);\n  return [clamp(firstIndexPadded, minFirstIndex, maxLastIndex), clamp(lastIndexPadded, minFirstIndex, maxLastIndex)];\n}\nexport function areRenderContextsEqual(context1, context2) {\n  if (context1 === context2) {\n    return true;\n  }\n  return context1.firstRowIndex === context2.firstRowIndex && context1.lastRowIndex === context2.lastRowIndex && context1.firstColumnIndex === context2.firstColumnIndex && context1.lastColumnIndex === context2.lastColumnIndex;\n}\nexport function computeOffsetLeft(columnPositions, renderContext, pinnedLeftLength) {\n  const left = (columnPositions[renderContext.firstColumnIndex] ?? 0) - (columnPositions[pinnedLeftLength] ?? 0);\n  return Math.abs(left);\n}\nfunction directionForDelta(dx, dy) {\n  if (dx === 0 && dy === 0) {\n    return ScrollDirection.NONE;\n  }\n  /* eslint-disable */\n  if (Math.abs(dy) >= Math.abs(dx)) {\n    if (dy > 0) {\n      return ScrollDirection.DOWN;\n    } else {\n      return ScrollDirection.UP;\n    }\n  } else {\n    if (dx > 0) {\n      return ScrollDirection.RIGHT;\n    } else {\n      return ScrollDirection.LEFT;\n    }\n  }\n  /* eslint-enable */\n}\nfunction bufferForDirection(isRtl, direction, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) {\n  if (isRtl) {\n    switch (direction) {\n      case ScrollDirection.LEFT:\n        direction = ScrollDirection.RIGHT;\n        break;\n      case ScrollDirection.RIGHT:\n        direction = ScrollDirection.LEFT;\n        break;\n      default:\n    }\n  }\n  switch (direction) {\n    case ScrollDirection.NONE:\n      return {\n        rowAfter: rowBufferPx,\n        rowBefore: rowBufferPx,\n        columnAfter: columnBufferPx,\n        columnBefore: columnBufferPx\n      };\n    case ScrollDirection.LEFT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: horizontalBuffer\n      };\n    case ScrollDirection.RIGHT:\n      return {\n        rowAfter: 0,\n        rowBefore: 0,\n        columnAfter: horizontalBuffer,\n        columnBefore: 0\n      };\n    case ScrollDirection.UP:\n      return {\n        rowAfter: 0,\n        rowBefore: verticalBuffer,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    case ScrollDirection.DOWN:\n      return {\n        rowAfter: verticalBuffer,\n        rowBefore: 0,\n        columnAfter: 0,\n        columnBefore: 0\n      };\n    default:\n      // eslint unable to figure out enum exhaustiveness\n      throw new Error('unreachable');\n  }\n}\nfunction createScrollCache(isRtl, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer) {\n  return {\n    direction: ScrollDirection.NONE,\n    buffer: bufferForDirection(isRtl, ScrollDirection.NONE, rowBufferPx, columnBufferPx, verticalBuffer, horizontalBuffer)\n  };\n}\nfunction createRange(from, to) {\n  return Array.from({\n    length: to - from\n  }).map((_, i) => from + i);\n}\nfunction getFirstNonSpannedColumnToRender({\n  api,\n  firstColumnToRender,\n  firstRowToRender,\n  lastRowToRender,\n  visibleRows\n}) {\n  let firstNonSpannedColumnToRender = firstColumnToRender;\n  let foundStableColumn = false;\n\n  // Keep checking columns until we find one that's not spanned in any visible row\n  while (!foundStableColumn && firstNonSpannedColumnToRender >= 0) {\n    foundStableColumn = true;\n    for (let i = firstRowToRender; i < lastRowToRender; i += 1) {\n      const row = visibleRows[i];\n      if (row) {\n        const rowId = visibleRows[i].id;\n        const cellColSpanInfo = api.getCellColSpanInfo(rowId, firstNonSpannedColumnToRender);\n        if (cellColSpanInfo && cellColSpanInfo.spannedByColSpan && cellColSpanInfo.leftVisibleCellIndex < firstNonSpannedColumnToRender) {\n          firstNonSpannedColumnToRender = cellColSpanInfo.leftVisibleCellIndex;\n          foundStableColumn = false;\n          break; // Check the new column index against the visible rows, because it might be spanned\n        }\n      }\n    }\n  }\n  return firstNonSpannedColumnToRender;\n}\nexport function roundToDecimalPlaces(value, decimals) {\n  return Math.round(value * 10 ** decimals) / 10 ** decimals;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}