{"ast":null,"code":"'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { Rowspan } from '@mui/x-virtualizer/features';\nimport { gridVisibleColumnDefinitionsSelector } from \"../columns/gridColumnsSelector.js\";\nimport { getVisibleRows } from \"../../utils/useGridVisibleRows.js\";\nimport { gridRenderContextSelector } from \"../virtualization/gridVirtualizationSelectors.js\";\nimport { getUnprocessedRange, isRowContextInitialized, getCellValue } from \"./gridRowSpanningUtils.js\";\nimport { useGridEvent } from \"../../utils/useGridEvent.js\";\nimport { runIf } from \"../../../utils/utils.js\";\nimport { gridPageSizeSelector } from \"../pagination/index.js\";\nimport { gridDataRowIdsSelector } from \"./gridRowsSelector.js\";\nconst EMPTY_CACHES = {\n  spannedCells: {},\n  hiddenCells: {},\n  hiddenCellOriginMap: {}\n};\nconst EMPTY_RANGE = {\n  firstRowIndex: 0,\n  lastRowIndex: 0\n};\nconst EMPTY_STATE = {\n  caches: EMPTY_CACHES,\n  processedRange: EMPTY_RANGE\n};\n\n/**\n * Default number of rows to process during state initialization to avoid flickering.\n * Number `20` is arbitrarily chosen to be large enough to cover most of the cases without\n * compromising performance.\n */\nconst DEFAULT_ROWS_TO_PROCESS = 20;\nconst computeRowSpanningState = (apiRef, colDefs, visibleRows, range, rangeToProcess, resetState) => {\n  const virtualizer = apiRef.current.virtualizer;\n  const previousState = resetState ? EMPTY_STATE : Rowspan.selectors.state(virtualizer.store.state);\n  const spannedCells = _extends({}, previousState.caches.spannedCells);\n  const hiddenCells = _extends({}, previousState.caches.hiddenCells);\n  const hiddenCellOriginMap = _extends({}, previousState.caches.hiddenCellOriginMap);\n  const processedRange = {\n    firstRowIndex: Math.min(previousState.processedRange.firstRowIndex, rangeToProcess.firstRowIndex),\n    lastRowIndex: Math.max(previousState.processedRange.lastRowIndex, rangeToProcess.lastRowIndex)\n  };\n  colDefs.forEach((colDef, columnIndex) => {\n    for (let index = rangeToProcess.firstRowIndex; index < rangeToProcess.lastRowIndex; index += 1) {\n      var _hiddenCells$row$id;\n      const row = visibleRows[index];\n      if ((_hiddenCells$row$id = hiddenCells[row.id]) !== null && _hiddenCells$row$id !== void 0 && _hiddenCells$row$id[columnIndex]) {\n        continue;\n      }\n      const cellValue = getCellValue(row.model, colDef, apiRef);\n      if (cellValue == null) {\n        continue;\n      }\n      let spannedRowId = row.id;\n      let spannedRowIndex = index;\n      let rowSpan = 0;\n\n      // For first index, also scan in the previous rows to handle the reset state case e.g by sorting\n      const backwardsHiddenCells = [];\n      if (index === rangeToProcess.firstRowIndex) {\n        let prevIndex = index - 1;\n        let prevRowEntry = visibleRows[prevIndex];\n        while (prevIndex >= range.firstRowIndex && prevRowEntry && getCellValue(prevRowEntry.model, colDef, apiRef) === cellValue) {\n          const currentRow = visibleRows[prevIndex + 1];\n          if (hiddenCells[currentRow.id]) {\n            hiddenCells[currentRow.id][columnIndex] = true;\n          } else {\n            hiddenCells[currentRow.id] = {\n              [columnIndex]: true\n            };\n          }\n          backwardsHiddenCells.push(index);\n          rowSpan += 1;\n          spannedRowId = prevRowEntry.id;\n          spannedRowIndex = prevIndex;\n          prevIndex -= 1;\n          prevRowEntry = visibleRows[prevIndex];\n        }\n      }\n      backwardsHiddenCells.forEach(hiddenCellIndex => {\n        if (hiddenCellOriginMap[hiddenCellIndex]) {\n          hiddenCellOriginMap[hiddenCellIndex][columnIndex] = spannedRowIndex;\n        } else {\n          hiddenCellOriginMap[hiddenCellIndex] = {\n            [columnIndex]: spannedRowIndex\n          };\n        }\n      });\n\n      // Scan the next rows\n      let relativeIndex = index + 1;\n      while (relativeIndex <= range.lastRowIndex && visibleRows[relativeIndex] && getCellValue(visibleRows[relativeIndex].model, colDef, apiRef) === cellValue) {\n        const currentRow = visibleRows[relativeIndex];\n        if (hiddenCells[currentRow.id]) {\n          hiddenCells[currentRow.id][columnIndex] = true;\n        } else {\n          hiddenCells[currentRow.id] = {\n            [columnIndex]: true\n          };\n        }\n        if (hiddenCellOriginMap[relativeIndex]) {\n          hiddenCellOriginMap[relativeIndex][columnIndex] = spannedRowIndex;\n        } else {\n          hiddenCellOriginMap[relativeIndex] = {\n            [columnIndex]: spannedRowIndex\n          };\n        }\n        relativeIndex += 1;\n        rowSpan += 1;\n      }\n      if (rowSpan > 0) {\n        if (spannedCells[spannedRowId]) {\n          spannedCells[spannedRowId][columnIndex] = rowSpan + 1;\n        } else {\n          spannedCells[spannedRowId] = {\n            [columnIndex]: rowSpan + 1\n          };\n        }\n      }\n    }\n  });\n  return {\n    caches: {\n      spannedCells,\n      hiddenCells,\n      hiddenCellOriginMap\n    },\n    processedRange\n  };\n};\nconst getInitialRangeToProcess = (props, apiRef) => {\n  const rowCount = gridDataRowIdsSelector(apiRef).length;\n  if (props.pagination) {\n    const pageSize = gridPageSizeSelector(apiRef);\n    let paginationLastRowIndex = DEFAULT_ROWS_TO_PROCESS;\n    if (pageSize > 0) {\n      paginationLastRowIndex = pageSize - 1;\n    }\n    return {\n      firstRowIndex: 0,\n      lastRowIndex: Math.min(paginationLastRowIndex, rowCount)\n    };\n  }\n  return {\n    firstRowIndex: 0,\n    lastRowIndex: Math.min(DEFAULT_ROWS_TO_PROCESS, rowCount)\n  };\n};\n\n/**\n * @requires columnsStateInitializer (method) - should be initialized before\n * @requires rowsStateInitializer (method) - should be initialized before\n * @requires filterStateInitializer (method) - should be initialized before\n */\nexport const rowSpanningStateInitializer = (state, props, apiRef) => {\n  var _state$filter$filterM;\n  if (!props.rowSpanning) {\n    return _extends({}, state, {\n      rowSpanning: EMPTY_STATE\n    });\n  }\n  const rowIds = state.rows.dataRowIds || [];\n  const orderedFields = state.columns.orderedFields || [];\n  const dataRowIdToModelLookup = state.rows.dataRowIdToModelLookup;\n  const columnsLookup = state.columns.lookup;\n  const isFilteringPending = Boolean(state.filter.filterModel.items.length) || Boolean((_state$filter$filterM = state.filter.filterModel.quickFilterValues) === null || _state$filter$filterM === void 0 ? void 0 : _state$filter$filterM.length);\n  if (!rowIds.length || !orderedFields.length || !dataRowIdToModelLookup || !columnsLookup || isFilteringPending) {\n    return _extends({}, state, {\n      rowSpanning: EMPTY_STATE\n    });\n  }\n  const rangeToProcess = getInitialRangeToProcess(props, apiRef);\n  const rows = rowIds.map(id => ({\n    id,\n    model: dataRowIdToModelLookup[id]\n  }));\n  const colDefs = orderedFields.map(field => columnsLookup[field]);\n  const rowSpanning = computeRowSpanningState(apiRef, colDefs, rows, rangeToProcess, rangeToProcess, true);\n  return _extends({}, state, {\n    rowSpanning\n  });\n};\nexport const useGridRowSpanning = (apiRef, props) => {\n  const store = apiRef.current.virtualizer.store;\n  const updateRowSpanningState = React.useCallback(function (renderContext) {\n    let resetState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const {\n      range,\n      rows: visibleRows\n    } = getVisibleRows(apiRef);\n    if (range === null || !isRowContextInitialized(renderContext)) {\n      return;\n    }\n    const previousState = resetState ? EMPTY_STATE : Rowspan.selectors.state(store.state);\n    const rangeToProcess = getUnprocessedRange({\n      firstRowIndex: renderContext.firstRowIndex,\n      lastRowIndex: Math.min(renderContext.lastRowIndex, range.lastRowIndex - range.firstRowIndex + 1)\n    }, previousState.processedRange);\n    if (rangeToProcess === null) {\n      return;\n    }\n    const colDefs = gridVisibleColumnDefinitionsSelector(apiRef);\n    const newState = computeRowSpanningState(apiRef, colDefs, visibleRows, range, rangeToProcess, resetState);\n    const newSpannedCellsCount = Object.keys(newState.caches.spannedCells).length;\n    const newHiddenCellsCount = Object.keys(newState.caches.hiddenCells).length;\n    const previousSpannedCellsCount = Object.keys(previousState.caches.spannedCells).length;\n    const previousHiddenCellsCount = Object.keys(previousState.caches.hiddenCells).length;\n    const shouldUpdateState = resetState || newSpannedCellsCount !== previousSpannedCellsCount || newHiddenCellsCount !== previousHiddenCellsCount;\n    const hasNoSpannedCells = newSpannedCellsCount === 0 && previousSpannedCellsCount === 0;\n    if (!shouldUpdateState || hasNoSpannedCells) {\n      return;\n    }\n    store.set('rowSpanning', newState);\n  }, [apiRef, store]);\n\n  // Reset events trigger a full re-computation of the row spanning state:\n  // - The `unstable_rowSpanning` prop is updated (feature flag)\n  // - The filtering is applied\n  // - The sorting is applied\n  // - The `paginationModel` is updated\n  // - The rows are updated\n  const resetRowSpanningState = React.useCallback(() => {\n    const renderContext = gridRenderContextSelector(apiRef);\n    if (!isRowContextInitialized(renderContext)) {\n      return;\n    }\n    updateRowSpanningState(renderContext, true);\n  }, [apiRef, updateRowSpanningState]);\n  useGridEvent(apiRef, 'renderedRowsIntervalChange', runIf(props.rowSpanning, updateRowSpanningState));\n  useGridEvent(apiRef, 'sortedRowsSet', runIf(props.rowSpanning, resetRowSpanningState));\n  useGridEvent(apiRef, 'paginationModelChange', runIf(props.rowSpanning, resetRowSpanningState));\n  useGridEvent(apiRef, 'filteredRowsSet', runIf(props.rowSpanning, resetRowSpanningState));\n  useGridEvent(apiRef, 'columnsChange', runIf(props.rowSpanning, resetRowSpanningState));\n  React.useEffect(() => {\n    if (!props.rowSpanning) {\n      if (store.state.rowSpanning !== EMPTY_STATE) {\n        store.set('rowSpanning', EMPTY_STATE);\n      }\n    } else if (store.state.rowSpanning.caches === EMPTY_CACHES) {\n      resetRowSpanningState();\n    }\n  }, [apiRef, store, resetRowSpanningState, props.rowSpanning]);\n};","map":{"version":3,"names":["_extends","React","Rowspan","gridVisibleColumnDefinitionsSelector","getVisibleRows","gridRenderContextSelector","getUnprocessedRange","isRowContextInitialized","getCellValue","useGridEvent","runIf","gridPageSizeSelector","gridDataRowIdsSelector","EMPTY_CACHES","spannedCells","hiddenCells","hiddenCellOriginMap","EMPTY_RANGE","firstRowIndex","lastRowIndex","EMPTY_STATE","caches","processedRange","DEFAULT_ROWS_TO_PROCESS","computeRowSpanningState","apiRef","colDefs","visibleRows","range","rangeToProcess","resetState","virtualizer","current","previousState","selectors","state","store","Math","min","max","forEach","colDef","columnIndex","index","_hiddenCells$row$id","row","id","cellValue","model","spannedRowId","spannedRowIndex","rowSpan","backwardsHiddenCells","prevIndex","prevRowEntry","currentRow","push","hiddenCellIndex","relativeIndex","getInitialRangeToProcess","props","rowCount","length","pagination","pageSize","paginationLastRowIndex","rowSpanningStateInitializer","_state$filter$filterM","rowSpanning","rowIds","rows","dataRowIds","orderedFields","columns","dataRowIdToModelLookup","columnsLookup","lookup","isFilteringPending","Boolean","filter","filterModel","items","quickFilterValues","map","field","useGridRowSpanning","updateRowSpanningState","useCallback","renderContext","arguments","undefined","newState","newSpannedCellsCount","Object","keys","newHiddenCellsCount","previousSpannedCellsCount","previousHiddenCellsCount","shouldUpdateState","hasNoSpannedCells","set","resetRowSpanningState","useEffect"],"sources":["C:/Users/mis/rbt-dashboard/node_modules/@mui/x-data-grid/esm/hooks/features/rows/useGridRowSpanning.js"],"sourcesContent":["'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { Rowspan } from '@mui/x-virtualizer/features';\nimport { gridVisibleColumnDefinitionsSelector } from \"../columns/gridColumnsSelector.js\";\nimport { getVisibleRows } from \"../../utils/useGridVisibleRows.js\";\nimport { gridRenderContextSelector } from \"../virtualization/gridVirtualizationSelectors.js\";\nimport { getUnprocessedRange, isRowContextInitialized, getCellValue } from \"./gridRowSpanningUtils.js\";\nimport { useGridEvent } from \"../../utils/useGridEvent.js\";\nimport { runIf } from \"../../../utils/utils.js\";\nimport { gridPageSizeSelector } from \"../pagination/index.js\";\nimport { gridDataRowIdsSelector } from \"./gridRowsSelector.js\";\nconst EMPTY_CACHES = {\n  spannedCells: {},\n  hiddenCells: {},\n  hiddenCellOriginMap: {}\n};\nconst EMPTY_RANGE = {\n  firstRowIndex: 0,\n  lastRowIndex: 0\n};\nconst EMPTY_STATE = {\n  caches: EMPTY_CACHES,\n  processedRange: EMPTY_RANGE\n};\n\n/**\n * Default number of rows to process during state initialization to avoid flickering.\n * Number `20` is arbitrarily chosen to be large enough to cover most of the cases without\n * compromising performance.\n */\nconst DEFAULT_ROWS_TO_PROCESS = 20;\nconst computeRowSpanningState = (apiRef, colDefs, visibleRows, range, rangeToProcess, resetState) => {\n  const virtualizer = apiRef.current.virtualizer;\n  const previousState = resetState ? EMPTY_STATE : Rowspan.selectors.state(virtualizer.store.state);\n  const spannedCells = _extends({}, previousState.caches.spannedCells);\n  const hiddenCells = _extends({}, previousState.caches.hiddenCells);\n  const hiddenCellOriginMap = _extends({}, previousState.caches.hiddenCellOriginMap);\n  const processedRange = {\n    firstRowIndex: Math.min(previousState.processedRange.firstRowIndex, rangeToProcess.firstRowIndex),\n    lastRowIndex: Math.max(previousState.processedRange.lastRowIndex, rangeToProcess.lastRowIndex)\n  };\n  colDefs.forEach((colDef, columnIndex) => {\n    for (let index = rangeToProcess.firstRowIndex; index < rangeToProcess.lastRowIndex; index += 1) {\n      const row = visibleRows[index];\n      if (hiddenCells[row.id]?.[columnIndex]) {\n        continue;\n      }\n      const cellValue = getCellValue(row.model, colDef, apiRef);\n      if (cellValue == null) {\n        continue;\n      }\n      let spannedRowId = row.id;\n      let spannedRowIndex = index;\n      let rowSpan = 0;\n\n      // For first index, also scan in the previous rows to handle the reset state case e.g by sorting\n      const backwardsHiddenCells = [];\n      if (index === rangeToProcess.firstRowIndex) {\n        let prevIndex = index - 1;\n        let prevRowEntry = visibleRows[prevIndex];\n        while (prevIndex >= range.firstRowIndex && prevRowEntry && getCellValue(prevRowEntry.model, colDef, apiRef) === cellValue) {\n          const currentRow = visibleRows[prevIndex + 1];\n          if (hiddenCells[currentRow.id]) {\n            hiddenCells[currentRow.id][columnIndex] = true;\n          } else {\n            hiddenCells[currentRow.id] = {\n              [columnIndex]: true\n            };\n          }\n          backwardsHiddenCells.push(index);\n          rowSpan += 1;\n          spannedRowId = prevRowEntry.id;\n          spannedRowIndex = prevIndex;\n          prevIndex -= 1;\n          prevRowEntry = visibleRows[prevIndex];\n        }\n      }\n      backwardsHiddenCells.forEach(hiddenCellIndex => {\n        if (hiddenCellOriginMap[hiddenCellIndex]) {\n          hiddenCellOriginMap[hiddenCellIndex][columnIndex] = spannedRowIndex;\n        } else {\n          hiddenCellOriginMap[hiddenCellIndex] = {\n            [columnIndex]: spannedRowIndex\n          };\n        }\n      });\n\n      // Scan the next rows\n      let relativeIndex = index + 1;\n      while (relativeIndex <= range.lastRowIndex && visibleRows[relativeIndex] && getCellValue(visibleRows[relativeIndex].model, colDef, apiRef) === cellValue) {\n        const currentRow = visibleRows[relativeIndex];\n        if (hiddenCells[currentRow.id]) {\n          hiddenCells[currentRow.id][columnIndex] = true;\n        } else {\n          hiddenCells[currentRow.id] = {\n            [columnIndex]: true\n          };\n        }\n        if (hiddenCellOriginMap[relativeIndex]) {\n          hiddenCellOriginMap[relativeIndex][columnIndex] = spannedRowIndex;\n        } else {\n          hiddenCellOriginMap[relativeIndex] = {\n            [columnIndex]: spannedRowIndex\n          };\n        }\n        relativeIndex += 1;\n        rowSpan += 1;\n      }\n      if (rowSpan > 0) {\n        if (spannedCells[spannedRowId]) {\n          spannedCells[spannedRowId][columnIndex] = rowSpan + 1;\n        } else {\n          spannedCells[spannedRowId] = {\n            [columnIndex]: rowSpan + 1\n          };\n        }\n      }\n    }\n  });\n  return {\n    caches: {\n      spannedCells,\n      hiddenCells,\n      hiddenCellOriginMap\n    },\n    processedRange\n  };\n};\nconst getInitialRangeToProcess = (props, apiRef) => {\n  const rowCount = gridDataRowIdsSelector(apiRef).length;\n  if (props.pagination) {\n    const pageSize = gridPageSizeSelector(apiRef);\n    let paginationLastRowIndex = DEFAULT_ROWS_TO_PROCESS;\n    if (pageSize > 0) {\n      paginationLastRowIndex = pageSize - 1;\n    }\n    return {\n      firstRowIndex: 0,\n      lastRowIndex: Math.min(paginationLastRowIndex, rowCount)\n    };\n  }\n  return {\n    firstRowIndex: 0,\n    lastRowIndex: Math.min(DEFAULT_ROWS_TO_PROCESS, rowCount)\n  };\n};\n\n/**\n * @requires columnsStateInitializer (method) - should be initialized before\n * @requires rowsStateInitializer (method) - should be initialized before\n * @requires filterStateInitializer (method) - should be initialized before\n */\nexport const rowSpanningStateInitializer = (state, props, apiRef) => {\n  if (!props.rowSpanning) {\n    return _extends({}, state, {\n      rowSpanning: EMPTY_STATE\n    });\n  }\n  const rowIds = state.rows.dataRowIds || [];\n  const orderedFields = state.columns.orderedFields || [];\n  const dataRowIdToModelLookup = state.rows.dataRowIdToModelLookup;\n  const columnsLookup = state.columns.lookup;\n  const isFilteringPending = Boolean(state.filter.filterModel.items.length) || Boolean(state.filter.filterModel.quickFilterValues?.length);\n  if (!rowIds.length || !orderedFields.length || !dataRowIdToModelLookup || !columnsLookup || isFilteringPending) {\n    return _extends({}, state, {\n      rowSpanning: EMPTY_STATE\n    });\n  }\n  const rangeToProcess = getInitialRangeToProcess(props, apiRef);\n  const rows = rowIds.map(id => ({\n    id,\n    model: dataRowIdToModelLookup[id]\n  }));\n  const colDefs = orderedFields.map(field => columnsLookup[field]);\n  const rowSpanning = computeRowSpanningState(apiRef, colDefs, rows, rangeToProcess, rangeToProcess, true);\n  return _extends({}, state, {\n    rowSpanning\n  });\n};\nexport const useGridRowSpanning = (apiRef, props) => {\n  const store = apiRef.current.virtualizer.store;\n  const updateRowSpanningState = React.useCallback((renderContext, resetState = false) => {\n    const {\n      range,\n      rows: visibleRows\n    } = getVisibleRows(apiRef);\n    if (range === null || !isRowContextInitialized(renderContext)) {\n      return;\n    }\n    const previousState = resetState ? EMPTY_STATE : Rowspan.selectors.state(store.state);\n    const rangeToProcess = getUnprocessedRange({\n      firstRowIndex: renderContext.firstRowIndex,\n      lastRowIndex: Math.min(renderContext.lastRowIndex, range.lastRowIndex - range.firstRowIndex + 1)\n    }, previousState.processedRange);\n    if (rangeToProcess === null) {\n      return;\n    }\n    const colDefs = gridVisibleColumnDefinitionsSelector(apiRef);\n    const newState = computeRowSpanningState(apiRef, colDefs, visibleRows, range, rangeToProcess, resetState);\n    const newSpannedCellsCount = Object.keys(newState.caches.spannedCells).length;\n    const newHiddenCellsCount = Object.keys(newState.caches.hiddenCells).length;\n    const previousSpannedCellsCount = Object.keys(previousState.caches.spannedCells).length;\n    const previousHiddenCellsCount = Object.keys(previousState.caches.hiddenCells).length;\n    const shouldUpdateState = resetState || newSpannedCellsCount !== previousSpannedCellsCount || newHiddenCellsCount !== previousHiddenCellsCount;\n    const hasNoSpannedCells = newSpannedCellsCount === 0 && previousSpannedCellsCount === 0;\n    if (!shouldUpdateState || hasNoSpannedCells) {\n      return;\n    }\n    store.set('rowSpanning', newState);\n  }, [apiRef, store]);\n\n  // Reset events trigger a full re-computation of the row spanning state:\n  // - The `unstable_rowSpanning` prop is updated (feature flag)\n  // - The filtering is applied\n  // - The sorting is applied\n  // - The `paginationModel` is updated\n  // - The rows are updated\n  const resetRowSpanningState = React.useCallback(() => {\n    const renderContext = gridRenderContextSelector(apiRef);\n    if (!isRowContextInitialized(renderContext)) {\n      return;\n    }\n    updateRowSpanningState(renderContext, true);\n  }, [apiRef, updateRowSpanningState]);\n  useGridEvent(apiRef, 'renderedRowsIntervalChange', runIf(props.rowSpanning, updateRowSpanningState));\n  useGridEvent(apiRef, 'sortedRowsSet', runIf(props.rowSpanning, resetRowSpanningState));\n  useGridEvent(apiRef, 'paginationModelChange', runIf(props.rowSpanning, resetRowSpanningState));\n  useGridEvent(apiRef, 'filteredRowsSet', runIf(props.rowSpanning, resetRowSpanningState));\n  useGridEvent(apiRef, 'columnsChange', runIf(props.rowSpanning, resetRowSpanningState));\n  React.useEffect(() => {\n    if (!props.rowSpanning) {\n      if (store.state.rowSpanning !== EMPTY_STATE) {\n        store.set('rowSpanning', EMPTY_STATE);\n      }\n    } else if (store.state.rowSpanning.caches === EMPTY_CACHES) {\n      resetRowSpanningState();\n    }\n  }, [apiRef, store, resetRowSpanningState, props.rowSpanning]);\n};"],"mappings":"AAAA,YAAY;;AAEZ,OAAOA,QAAQ,MAAM,oCAAoC;AACzD,OAAO,KAAKC,KAAK,MAAM,OAAO;AAC9B,SAASC,OAAO,QAAQ,6BAA6B;AACrD,SAASC,oCAAoC,QAAQ,mCAAmC;AACxF,SAASC,cAAc,QAAQ,mCAAmC;AAClE,SAASC,yBAAyB,QAAQ,kDAAkD;AAC5F,SAASC,mBAAmB,EAAEC,uBAAuB,EAAEC,YAAY,QAAQ,2BAA2B;AACtG,SAASC,YAAY,QAAQ,6BAA6B;AAC1D,SAASC,KAAK,QAAQ,yBAAyB;AAC/C,SAASC,oBAAoB,QAAQ,wBAAwB;AAC7D,SAASC,sBAAsB,QAAQ,uBAAuB;AAC9D,MAAMC,YAAY,GAAG;EACnBC,YAAY,EAAE,CAAC,CAAC;EAChBC,WAAW,EAAE,CAAC,CAAC;EACfC,mBAAmB,EAAE,CAAC;AACxB,CAAC;AACD,MAAMC,WAAW,GAAG;EAClBC,aAAa,EAAE,CAAC;EAChBC,YAAY,EAAE;AAChB,CAAC;AACD,MAAMC,WAAW,GAAG;EAClBC,MAAM,EAAER,YAAY;EACpBS,cAAc,EAAEL;AAClB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,MAAMM,uBAAuB,GAAG,EAAE;AAClC,MAAMC,uBAAuB,GAAGA,CAACC,MAAM,EAAEC,OAAO,EAAEC,WAAW,EAAEC,KAAK,EAAEC,cAAc,EAAEC,UAAU,KAAK;EACnG,MAAMC,WAAW,GAAGN,MAAM,CAACO,OAAO,CAACD,WAAW;EAC9C,MAAME,aAAa,GAAGH,UAAU,GAAGV,WAAW,GAAGlB,OAAO,CAACgC,SAAS,CAACC,KAAK,CAACJ,WAAW,CAACK,KAAK,CAACD,KAAK,CAAC;EACjG,MAAMrB,YAAY,GAAGd,QAAQ,CAAC,CAAC,CAAC,EAAEiC,aAAa,CAACZ,MAAM,CAACP,YAAY,CAAC;EACpE,MAAMC,WAAW,GAAGf,QAAQ,CAAC,CAAC,CAAC,EAAEiC,aAAa,CAACZ,MAAM,CAACN,WAAW,CAAC;EAClE,MAAMC,mBAAmB,GAAGhB,QAAQ,CAAC,CAAC,CAAC,EAAEiC,aAAa,CAACZ,MAAM,CAACL,mBAAmB,CAAC;EAClF,MAAMM,cAAc,GAAG;IACrBJ,aAAa,EAAEmB,IAAI,CAACC,GAAG,CAACL,aAAa,CAACX,cAAc,CAACJ,aAAa,EAAEW,cAAc,CAACX,aAAa,CAAC;IACjGC,YAAY,EAAEkB,IAAI,CAACE,GAAG,CAACN,aAAa,CAACX,cAAc,CAACH,YAAY,EAAEU,cAAc,CAACV,YAAY;EAC/F,CAAC;EACDO,OAAO,CAACc,OAAO,CAAC,CAACC,MAAM,EAAEC,WAAW,KAAK;IACvC,KAAK,IAAIC,KAAK,GAAGd,cAAc,CAACX,aAAa,EAAEyB,KAAK,GAAGd,cAAc,CAACV,YAAY,EAAEwB,KAAK,IAAI,CAAC,EAAE;MAAA,IAAAC,mBAAA;MAC9F,MAAMC,GAAG,GAAGlB,WAAW,CAACgB,KAAK,CAAC;MAC9B,KAAAC,mBAAA,GAAI7B,WAAW,CAAC8B,GAAG,CAACC,EAAE,CAAC,cAAAF,mBAAA,eAAnBA,mBAAA,CAAsBF,WAAW,CAAC,EAAE;QACtC;MACF;MACA,MAAMK,SAAS,GAAGvC,YAAY,CAACqC,GAAG,CAACG,KAAK,EAAEP,MAAM,EAAEhB,MAAM,CAAC;MACzD,IAAIsB,SAAS,IAAI,IAAI,EAAE;QACrB;MACF;MACA,IAAIE,YAAY,GAAGJ,GAAG,CAACC,EAAE;MACzB,IAAII,eAAe,GAAGP,KAAK;MAC3B,IAAIQ,OAAO,GAAG,CAAC;;MAEf;MACA,MAAMC,oBAAoB,GAAG,EAAE;MAC/B,IAAIT,KAAK,KAAKd,cAAc,CAACX,aAAa,EAAE;QAC1C,IAAImC,SAAS,GAAGV,KAAK,GAAG,CAAC;QACzB,IAAIW,YAAY,GAAG3B,WAAW,CAAC0B,SAAS,CAAC;QACzC,OAAOA,SAAS,IAAIzB,KAAK,CAACV,aAAa,IAAIoC,YAAY,IAAI9C,YAAY,CAAC8C,YAAY,CAACN,KAAK,EAAEP,MAAM,EAAEhB,MAAM,CAAC,KAAKsB,SAAS,EAAE;UACzH,MAAMQ,UAAU,GAAG5B,WAAW,CAAC0B,SAAS,GAAG,CAAC,CAAC;UAC7C,IAAItC,WAAW,CAACwC,UAAU,CAACT,EAAE,CAAC,EAAE;YAC9B/B,WAAW,CAACwC,UAAU,CAACT,EAAE,CAAC,CAACJ,WAAW,CAAC,GAAG,IAAI;UAChD,CAAC,MAAM;YACL3B,WAAW,CAACwC,UAAU,CAACT,EAAE,CAAC,GAAG;cAC3B,CAACJ,WAAW,GAAG;YACjB,CAAC;UACH;UACAU,oBAAoB,CAACI,IAAI,CAACb,KAAK,CAAC;UAChCQ,OAAO,IAAI,CAAC;UACZF,YAAY,GAAGK,YAAY,CAACR,EAAE;UAC9BI,eAAe,GAAGG,SAAS;UAC3BA,SAAS,IAAI,CAAC;UACdC,YAAY,GAAG3B,WAAW,CAAC0B,SAAS,CAAC;QACvC;MACF;MACAD,oBAAoB,CAACZ,OAAO,CAACiB,eAAe,IAAI;QAC9C,IAAIzC,mBAAmB,CAACyC,eAAe,CAAC,EAAE;UACxCzC,mBAAmB,CAACyC,eAAe,CAAC,CAACf,WAAW,CAAC,GAAGQ,eAAe;QACrE,CAAC,MAAM;UACLlC,mBAAmB,CAACyC,eAAe,CAAC,GAAG;YACrC,CAACf,WAAW,GAAGQ;UACjB,CAAC;QACH;MACF,CAAC,CAAC;;MAEF;MACA,IAAIQ,aAAa,GAAGf,KAAK,GAAG,CAAC;MAC7B,OAAOe,aAAa,IAAI9B,KAAK,CAACT,YAAY,IAAIQ,WAAW,CAAC+B,aAAa,CAAC,IAAIlD,YAAY,CAACmB,WAAW,CAAC+B,aAAa,CAAC,CAACV,KAAK,EAAEP,MAAM,EAAEhB,MAAM,CAAC,KAAKsB,SAAS,EAAE;QACxJ,MAAMQ,UAAU,GAAG5B,WAAW,CAAC+B,aAAa,CAAC;QAC7C,IAAI3C,WAAW,CAACwC,UAAU,CAACT,EAAE,CAAC,EAAE;UAC9B/B,WAAW,CAACwC,UAAU,CAACT,EAAE,CAAC,CAACJ,WAAW,CAAC,GAAG,IAAI;QAChD,CAAC,MAAM;UACL3B,WAAW,CAACwC,UAAU,CAACT,EAAE,CAAC,GAAG;YAC3B,CAACJ,WAAW,GAAG;UACjB,CAAC;QACH;QACA,IAAI1B,mBAAmB,CAAC0C,aAAa,CAAC,EAAE;UACtC1C,mBAAmB,CAAC0C,aAAa,CAAC,CAAChB,WAAW,CAAC,GAAGQ,eAAe;QACnE,CAAC,MAAM;UACLlC,mBAAmB,CAAC0C,aAAa,CAAC,GAAG;YACnC,CAAChB,WAAW,GAAGQ;UACjB,CAAC;QACH;QACAQ,aAAa,IAAI,CAAC;QAClBP,OAAO,IAAI,CAAC;MACd;MACA,IAAIA,OAAO,GAAG,CAAC,EAAE;QACf,IAAIrC,YAAY,CAACmC,YAAY,CAAC,EAAE;UAC9BnC,YAAY,CAACmC,YAAY,CAAC,CAACP,WAAW,CAAC,GAAGS,OAAO,GAAG,CAAC;QACvD,CAAC,MAAM;UACLrC,YAAY,CAACmC,YAAY,CAAC,GAAG;YAC3B,CAACP,WAAW,GAAGS,OAAO,GAAG;UAC3B,CAAC;QACH;MACF;IACF;EACF,CAAC,CAAC;EACF,OAAO;IACL9B,MAAM,EAAE;MACNP,YAAY;MACZC,WAAW;MACXC;IACF,CAAC;IACDM;EACF,CAAC;AACH,CAAC;AACD,MAAMqC,wBAAwB,GAAGA,CAACC,KAAK,EAAEnC,MAAM,KAAK;EAClD,MAAMoC,QAAQ,GAAGjD,sBAAsB,CAACa,MAAM,CAAC,CAACqC,MAAM;EACtD,IAAIF,KAAK,CAACG,UAAU,EAAE;IACpB,MAAMC,QAAQ,GAAGrD,oBAAoB,CAACc,MAAM,CAAC;IAC7C,IAAIwC,sBAAsB,GAAG1C,uBAAuB;IACpD,IAAIyC,QAAQ,GAAG,CAAC,EAAE;MAChBC,sBAAsB,GAAGD,QAAQ,GAAG,CAAC;IACvC;IACA,OAAO;MACL9C,aAAa,EAAE,CAAC;MAChBC,YAAY,EAAEkB,IAAI,CAACC,GAAG,CAAC2B,sBAAsB,EAAEJ,QAAQ;IACzD,CAAC;EACH;EACA,OAAO;IACL3C,aAAa,EAAE,CAAC;IAChBC,YAAY,EAAEkB,IAAI,CAACC,GAAG,CAACf,uBAAuB,EAAEsC,QAAQ;EAC1D,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMK,2BAA2B,GAAGA,CAAC/B,KAAK,EAAEyB,KAAK,EAAEnC,MAAM,KAAK;EAAA,IAAA0C,qBAAA;EACnE,IAAI,CAACP,KAAK,CAACQ,WAAW,EAAE;IACtB,OAAOpE,QAAQ,CAAC,CAAC,CAAC,EAAEmC,KAAK,EAAE;MACzBiC,WAAW,EAAEhD;IACf,CAAC,CAAC;EACJ;EACA,MAAMiD,MAAM,GAAGlC,KAAK,CAACmC,IAAI,CAACC,UAAU,IAAI,EAAE;EAC1C,MAAMC,aAAa,GAAGrC,KAAK,CAACsC,OAAO,CAACD,aAAa,IAAI,EAAE;EACvD,MAAME,sBAAsB,GAAGvC,KAAK,CAACmC,IAAI,CAACI,sBAAsB;EAChE,MAAMC,aAAa,GAAGxC,KAAK,CAACsC,OAAO,CAACG,MAAM;EAC1C,MAAMC,kBAAkB,GAAGC,OAAO,CAAC3C,KAAK,CAAC4C,MAAM,CAACC,WAAW,CAACC,KAAK,CAACnB,MAAM,CAAC,IAAIgB,OAAO,EAAAX,qBAAA,GAAChC,KAAK,CAAC4C,MAAM,CAACC,WAAW,CAACE,iBAAiB,cAAAf,qBAAA,uBAA1CA,qBAAA,CAA4CL,MAAM,CAAC;EACxI,IAAI,CAACO,MAAM,CAACP,MAAM,IAAI,CAACU,aAAa,CAACV,MAAM,IAAI,CAACY,sBAAsB,IAAI,CAACC,aAAa,IAAIE,kBAAkB,EAAE;IAC9G,OAAO7E,QAAQ,CAAC,CAAC,CAAC,EAAEmC,KAAK,EAAE;MACzBiC,WAAW,EAAEhD;IACf,CAAC,CAAC;EACJ;EACA,MAAMS,cAAc,GAAG8B,wBAAwB,CAACC,KAAK,EAAEnC,MAAM,CAAC;EAC9D,MAAM6C,IAAI,GAAGD,MAAM,CAACc,GAAG,CAACrC,EAAE,KAAK;IAC7BA,EAAE;IACFE,KAAK,EAAE0B,sBAAsB,CAAC5B,EAAE;EAClC,CAAC,CAAC,CAAC;EACH,MAAMpB,OAAO,GAAG8C,aAAa,CAACW,GAAG,CAACC,KAAK,IAAIT,aAAa,CAACS,KAAK,CAAC,CAAC;EAChE,MAAMhB,WAAW,GAAG5C,uBAAuB,CAACC,MAAM,EAAEC,OAAO,EAAE4C,IAAI,EAAEzC,cAAc,EAAEA,cAAc,EAAE,IAAI,CAAC;EACxG,OAAO7B,QAAQ,CAAC,CAAC,CAAC,EAAEmC,KAAK,EAAE;IACzBiC;EACF,CAAC,CAAC;AACJ,CAAC;AACD,OAAO,MAAMiB,kBAAkB,GAAGA,CAAC5D,MAAM,EAAEmC,KAAK,KAAK;EACnD,MAAMxB,KAAK,GAAGX,MAAM,CAACO,OAAO,CAACD,WAAW,CAACK,KAAK;EAC9C,MAAMkD,sBAAsB,GAAGrF,KAAK,CAACsF,WAAW,CAAC,UAACC,aAAa,EAAyB;IAAA,IAAvB1D,UAAU,GAAA2D,SAAA,CAAA3B,MAAA,QAAA2B,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAG,KAAK;IACjF,MAAM;MACJ7D,KAAK;MACL0C,IAAI,EAAE3C;IACR,CAAC,GAAGvB,cAAc,CAACqB,MAAM,CAAC;IAC1B,IAAIG,KAAK,KAAK,IAAI,IAAI,CAACrB,uBAAuB,CAACiF,aAAa,CAAC,EAAE;MAC7D;IACF;IACA,MAAMvD,aAAa,GAAGH,UAAU,GAAGV,WAAW,GAAGlB,OAAO,CAACgC,SAAS,CAACC,KAAK,CAACC,KAAK,CAACD,KAAK,CAAC;IACrF,MAAMN,cAAc,GAAGvB,mBAAmB,CAAC;MACzCY,aAAa,EAAEsE,aAAa,CAACtE,aAAa;MAC1CC,YAAY,EAAEkB,IAAI,CAACC,GAAG,CAACkD,aAAa,CAACrE,YAAY,EAAES,KAAK,CAACT,YAAY,GAAGS,KAAK,CAACV,aAAa,GAAG,CAAC;IACjG,CAAC,EAAEe,aAAa,CAACX,cAAc,CAAC;IAChC,IAAIO,cAAc,KAAK,IAAI,EAAE;MAC3B;IACF;IACA,MAAMH,OAAO,GAAGvB,oCAAoC,CAACsB,MAAM,CAAC;IAC5D,MAAMkE,QAAQ,GAAGnE,uBAAuB,CAACC,MAAM,EAAEC,OAAO,EAAEC,WAAW,EAAEC,KAAK,EAAEC,cAAc,EAAEC,UAAU,CAAC;IACzG,MAAM8D,oBAAoB,GAAGC,MAAM,CAACC,IAAI,CAACH,QAAQ,CAACtE,MAAM,CAACP,YAAY,CAAC,CAACgD,MAAM;IAC7E,MAAMiC,mBAAmB,GAAGF,MAAM,CAACC,IAAI,CAACH,QAAQ,CAACtE,MAAM,CAACN,WAAW,CAAC,CAAC+C,MAAM;IAC3E,MAAMkC,yBAAyB,GAAGH,MAAM,CAACC,IAAI,CAAC7D,aAAa,CAACZ,MAAM,CAACP,YAAY,CAAC,CAACgD,MAAM;IACvF,MAAMmC,wBAAwB,GAAGJ,MAAM,CAACC,IAAI,CAAC7D,aAAa,CAACZ,MAAM,CAACN,WAAW,CAAC,CAAC+C,MAAM;IACrF,MAAMoC,iBAAiB,GAAGpE,UAAU,IAAI8D,oBAAoB,KAAKI,yBAAyB,IAAID,mBAAmB,KAAKE,wBAAwB;IAC9I,MAAME,iBAAiB,GAAGP,oBAAoB,KAAK,CAAC,IAAII,yBAAyB,KAAK,CAAC;IACvF,IAAI,CAACE,iBAAiB,IAAIC,iBAAiB,EAAE;MAC3C;IACF;IACA/D,KAAK,CAACgE,GAAG,CAAC,aAAa,EAAET,QAAQ,CAAC;EACpC,CAAC,EAAE,CAAClE,MAAM,EAAEW,KAAK,CAAC,CAAC;;EAEnB;EACA;EACA;EACA;EACA;EACA;EACA,MAAMiE,qBAAqB,GAAGpG,KAAK,CAACsF,WAAW,CAAC,MAAM;IACpD,MAAMC,aAAa,GAAGnF,yBAAyB,CAACoB,MAAM,CAAC;IACvD,IAAI,CAAClB,uBAAuB,CAACiF,aAAa,CAAC,EAAE;MAC3C;IACF;IACAF,sBAAsB,CAACE,aAAa,EAAE,IAAI,CAAC;EAC7C,CAAC,EAAE,CAAC/D,MAAM,EAAE6D,sBAAsB,CAAC,CAAC;EACpC7E,YAAY,CAACgB,MAAM,EAAE,4BAA4B,EAAEf,KAAK,CAACkD,KAAK,CAACQ,WAAW,EAAEkB,sBAAsB,CAAC,CAAC;EACpG7E,YAAY,CAACgB,MAAM,EAAE,eAAe,EAAEf,KAAK,CAACkD,KAAK,CAACQ,WAAW,EAAEiC,qBAAqB,CAAC,CAAC;EACtF5F,YAAY,CAACgB,MAAM,EAAE,uBAAuB,EAAEf,KAAK,CAACkD,KAAK,CAACQ,WAAW,EAAEiC,qBAAqB,CAAC,CAAC;EAC9F5F,YAAY,CAACgB,MAAM,EAAE,iBAAiB,EAAEf,KAAK,CAACkD,KAAK,CAACQ,WAAW,EAAEiC,qBAAqB,CAAC,CAAC;EACxF5F,YAAY,CAACgB,MAAM,EAAE,eAAe,EAAEf,KAAK,CAACkD,KAAK,CAACQ,WAAW,EAAEiC,qBAAqB,CAAC,CAAC;EACtFpG,KAAK,CAACqG,SAAS,CAAC,MAAM;IACpB,IAAI,CAAC1C,KAAK,CAACQ,WAAW,EAAE;MACtB,IAAIhC,KAAK,CAACD,KAAK,CAACiC,WAAW,KAAKhD,WAAW,EAAE;QAC3CgB,KAAK,CAACgE,GAAG,CAAC,aAAa,EAAEhF,WAAW,CAAC;MACvC;IACF,CAAC,MAAM,IAAIgB,KAAK,CAACD,KAAK,CAACiC,WAAW,CAAC/C,MAAM,KAAKR,YAAY,EAAE;MAC1DwF,qBAAqB,CAAC,CAAC;IACzB;EACF,CAAC,EAAE,CAAC5E,MAAM,EAAEW,KAAK,EAAEiE,qBAAqB,EAAEzC,KAAK,CAACQ,WAAW,CAAC,CAAC;AAC/D,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}