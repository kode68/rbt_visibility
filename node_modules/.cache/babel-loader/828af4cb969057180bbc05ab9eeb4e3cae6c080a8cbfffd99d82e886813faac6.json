{"ast":null,"code":"import { GridSignature } from \"../../../constants/signature.js\";\nimport { GRID_ROOT_GROUP_ID } from \"../rows/gridRowsUtils.js\";\nimport { gridFilteredRowsLookupSelector } from \"../filter/gridFilterSelector.js\";\nimport { gridSortedRowIdsSelector } from \"../sorting/gridSortingSelector.js\";\nimport { gridRowSelectionManagerSelector } from \"./gridRowSelectionSelector.js\";\nimport { gridRowTreeSelector } from \"../rows/gridRowsSelector.js\";\nimport { createSelector } from \"../../../utils/createSelector.js\";\nexport const ROW_SELECTION_PROPAGATION_DEFAULT = {\n  parents: true,\n  descendants: true\n};\nfunction getGridRowGroupSelectableDescendants(apiRef, groupId) {\n  const rowTree = gridRowTreeSelector(apiRef);\n  const sortedRowIds = gridSortedRowIdsSelector(apiRef);\n  const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n  const groupNode = rowTree[groupId];\n  if (!groupNode || groupNode.type !== 'group') {\n    return [];\n  }\n  const descendants = [];\n  const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n  for (let index = startIndex; index < sortedRowIds.length && rowTree[sortedRowIds[index]]?.depth > groupNode.depth; index += 1) {\n    const id = sortedRowIds[index];\n    if (filteredRowsLookup[id] !== false && apiRef.current.isRowSelectable(id)) {\n      descendants.push(id);\n    }\n  }\n  return descendants;\n}\nexport const checkboxPropsSelector = createSelector(gridRowTreeSelector, gridFilteredRowsLookupSelector, gridRowSelectionManagerSelector, (rowTree, filteredRowsLookup, rowSelectionManager, _ref) => {\n  let {\n    groupId,\n    autoSelectParents\n  } = _ref;\n  const groupNode = rowTree[groupId];\n  if (!groupNode || groupNode.type !== 'group' || rowSelectionManager.has(groupId)) {\n    return {\n      isIndeterminate: false,\n      isChecked: rowSelectionManager.has(groupId)\n    };\n  }\n  let hasSelectedDescendant = false;\n  let hasUnSelectedDescendant = false;\n  const traverseDescendants = itemToTraverseId => {\n    if (filteredRowsLookup[itemToTraverseId] === false ||\n    // Perf: Skip checking the rest of the descendants if we already\n    // know that there is a selected and an unselected descendant\n    hasSelectedDescendant && hasUnSelectedDescendant) {\n      return;\n    }\n    const node = rowTree[itemToTraverseId];\n    if (node?.type === 'group') {\n      node.children.forEach(traverseDescendants);\n    }\n    if (rowSelectionManager.has(itemToTraverseId)) {\n      hasSelectedDescendant = true;\n    } else {\n      hasUnSelectedDescendant = true;\n    }\n  };\n  traverseDescendants(groupId);\n  return {\n    isIndeterminate: hasSelectedDescendant && hasUnSelectedDescendant,\n    isChecked: autoSelectParents ? hasSelectedDescendant && !hasUnSelectedDescendant : false\n  };\n});\nexport function isMultipleRowSelectionEnabled(props) {\n  if (props.signature === GridSignature.DataGrid) {\n    // DataGrid Community has multiple row selection enabled only if checkbox selection is enabled.\n    return props.checkboxSelection && props.disableMultipleRowSelection !== true;\n  }\n  return !props.disableMultipleRowSelection;\n}\nconst getRowNodeParents = (tree, id) => {\n  const parents = [];\n  let parent = id;\n  while (parent != null && parent !== GRID_ROOT_GROUP_ID) {\n    const node = tree[parent];\n    if (!node) {\n      return parents;\n    }\n    parents.push(parent);\n    parent = node.parent;\n  }\n  return parents;\n};\nconst getFilteredRowNodeSiblings = (tree, filteredRows, id) => {\n  const node = tree[id];\n  if (!node) {\n    return [];\n  }\n  const parent = node.parent;\n  if (parent == null) {\n    return [];\n  }\n  const parentNode = tree[parent];\n  return parentNode.children.filter(childId => childId !== id && filteredRows[childId] !== false);\n};\nexport const findRowsToSelect = function (apiRef, tree, selectedRow, autoSelectDescendants, autoSelectParents, addRow) {\n  let rowSelectionManager = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : gridRowSelectionManagerSelector(apiRef);\n  const filteredRows = gridFilteredRowsLookupSelector(apiRef);\n  const selectedDescendants = new Set([]);\n  if (!autoSelectDescendants && !autoSelectParents || filteredRows[selectedRow] === false) {\n    return;\n  }\n  if (autoSelectDescendants) {\n    const rowNode = tree[selectedRow];\n    if (rowNode?.type === 'group') {\n      const descendants = getGridRowGroupSelectableDescendants(apiRef, selectedRow);\n      descendants.forEach(rowId => {\n        addRow(rowId);\n        selectedDescendants.add(rowId);\n      });\n    }\n  }\n  if (autoSelectParents) {\n    const checkAllDescendantsSelected = rowId => {\n      if (!rowSelectionManager.has(rowId) && !selectedDescendants.has(rowId)) {\n        return false;\n      }\n      const node = tree[rowId];\n      if (!node) {\n        return false;\n      }\n      if (node.type !== 'group') {\n        return true;\n      }\n      return node.children.every(checkAllDescendantsSelected);\n    };\n    const traverseParents = rowId => {\n      const siblings = getFilteredRowNodeSiblings(tree, filteredRows, rowId);\n      if (siblings.length === 0 || siblings.every(checkAllDescendantsSelected)) {\n        const rowNode = tree[rowId];\n        const parent = rowNode?.parent;\n        if (parent != null && parent !== GRID_ROOT_GROUP_ID && apiRef.current.isRowSelectable(parent)) {\n          addRow(parent);\n          selectedDescendants.add(parent);\n          traverseParents(parent);\n        }\n      }\n    };\n    traverseParents(selectedRow);\n  }\n};\nexport const findRowsToDeselect = (apiRef, tree, deselectedRow, autoSelectDescendants, autoSelectParents, removeRow) => {\n  const rowSelectionManager = gridRowSelectionManagerSelector(apiRef);\n  if (!autoSelectParents && !autoSelectDescendants) {\n    return;\n  }\n  if (autoSelectParents) {\n    const allParents = getRowNodeParents(tree, deselectedRow);\n    allParents.forEach(parent => {\n      const isSelected = rowSelectionManager.has(parent);\n      if (isSelected) {\n        removeRow(parent);\n      }\n    });\n  }\n  if (autoSelectDescendants) {\n    const rowNode = tree[deselectedRow];\n    if (rowNode?.type === 'group') {\n      const descendants = getGridRowGroupSelectableDescendants(apiRef, deselectedRow);\n      descendants.forEach(descendant => {\n        removeRow(descendant);\n      });\n    }\n  }\n};","map":{"version":3,"names":["GridSignature","GRID_ROOT_GROUP_ID","gridFilteredRowsLookupSelector","gridSortedRowIdsSelector","gridRowSelectionManagerSelector","gridRowTreeSelector","createSelector","ROW_SELECTION_PROPAGATION_DEFAULT","parents","descendants","getGridRowGroupSelectableDescendants","apiRef","groupId","rowTree","sortedRowIds","filteredRowsLookup","groupNode","type","startIndex","findIndex","id","index","length","depth","current","isRowSelectable","push","checkboxPropsSelector","rowSelectionManager","_ref","autoSelectParents","has","isIndeterminate","isChecked","hasSelectedDescendant","hasUnSelectedDescendant","traverseDescendants","itemToTraverseId","node","children","forEach","isMultipleRowSelectionEnabled","props","signature","DataGrid","checkboxSelection","disableMultipleRowSelection","getRowNodeParents","tree","parent","getFilteredRowNodeSiblings","filteredRows","parentNode","filter","childId","findRowsToSelect","selectedRow","autoSelectDescendants","addRow","arguments","undefined","selectedDescendants","Set","rowNode","rowId","add","checkAllDescendantsSelected","every","traverseParents","siblings","findRowsToDeselect","deselectedRow","removeRow","allParents","isSelected","descendant"],"sources":["C:/Users/mis/rbt-dashboard/node_modules/@mui/x-data-grid/esm/hooks/features/rowSelection/utils.js"],"sourcesContent":["import { GridSignature } from \"../../../constants/signature.js\";\nimport { GRID_ROOT_GROUP_ID } from \"../rows/gridRowsUtils.js\";\nimport { gridFilteredRowsLookupSelector } from \"../filter/gridFilterSelector.js\";\nimport { gridSortedRowIdsSelector } from \"../sorting/gridSortingSelector.js\";\nimport { gridRowSelectionManagerSelector } from \"./gridRowSelectionSelector.js\";\nimport { gridRowTreeSelector } from \"../rows/gridRowsSelector.js\";\nimport { createSelector } from \"../../../utils/createSelector.js\";\nexport const ROW_SELECTION_PROPAGATION_DEFAULT = {\n  parents: true,\n  descendants: true\n};\nfunction getGridRowGroupSelectableDescendants(apiRef, groupId) {\n  const rowTree = gridRowTreeSelector(apiRef);\n  const sortedRowIds = gridSortedRowIdsSelector(apiRef);\n  const filteredRowsLookup = gridFilteredRowsLookupSelector(apiRef);\n  const groupNode = rowTree[groupId];\n  if (!groupNode || groupNode.type !== 'group') {\n    return [];\n  }\n  const descendants = [];\n  const startIndex = sortedRowIds.findIndex(id => id === groupId) + 1;\n  for (let index = startIndex; index < sortedRowIds.length && rowTree[sortedRowIds[index]]?.depth > groupNode.depth; index += 1) {\n    const id = sortedRowIds[index];\n    if (filteredRowsLookup[id] !== false && apiRef.current.isRowSelectable(id)) {\n      descendants.push(id);\n    }\n  }\n  return descendants;\n}\nexport const checkboxPropsSelector = createSelector(gridRowTreeSelector, gridFilteredRowsLookupSelector, gridRowSelectionManagerSelector, (rowTree, filteredRowsLookup, rowSelectionManager, {\n  groupId,\n  autoSelectParents\n}) => {\n  const groupNode = rowTree[groupId];\n  if (!groupNode || groupNode.type !== 'group' || rowSelectionManager.has(groupId)) {\n    return {\n      isIndeterminate: false,\n      isChecked: rowSelectionManager.has(groupId)\n    };\n  }\n  let hasSelectedDescendant = false;\n  let hasUnSelectedDescendant = false;\n  const traverseDescendants = itemToTraverseId => {\n    if (filteredRowsLookup[itemToTraverseId] === false ||\n    // Perf: Skip checking the rest of the descendants if we already\n    // know that there is a selected and an unselected descendant\n    hasSelectedDescendant && hasUnSelectedDescendant) {\n      return;\n    }\n    const node = rowTree[itemToTraverseId];\n    if (node?.type === 'group') {\n      node.children.forEach(traverseDescendants);\n    }\n    if (rowSelectionManager.has(itemToTraverseId)) {\n      hasSelectedDescendant = true;\n    } else {\n      hasUnSelectedDescendant = true;\n    }\n  };\n  traverseDescendants(groupId);\n  return {\n    isIndeterminate: hasSelectedDescendant && hasUnSelectedDescendant,\n    isChecked: autoSelectParents ? hasSelectedDescendant && !hasUnSelectedDescendant : false\n  };\n});\nexport function isMultipleRowSelectionEnabled(props) {\n  if (props.signature === GridSignature.DataGrid) {\n    // DataGrid Community has multiple row selection enabled only if checkbox selection is enabled.\n    return props.checkboxSelection && props.disableMultipleRowSelection !== true;\n  }\n  return !props.disableMultipleRowSelection;\n}\nconst getRowNodeParents = (tree, id) => {\n  const parents = [];\n  let parent = id;\n  while (parent != null && parent !== GRID_ROOT_GROUP_ID) {\n    const node = tree[parent];\n    if (!node) {\n      return parents;\n    }\n    parents.push(parent);\n    parent = node.parent;\n  }\n  return parents;\n};\nconst getFilteredRowNodeSiblings = (tree, filteredRows, id) => {\n  const node = tree[id];\n  if (!node) {\n    return [];\n  }\n  const parent = node.parent;\n  if (parent == null) {\n    return [];\n  }\n  const parentNode = tree[parent];\n  return parentNode.children.filter(childId => childId !== id && filteredRows[childId] !== false);\n};\nexport const findRowsToSelect = (apiRef, tree, selectedRow, autoSelectDescendants, autoSelectParents, addRow, rowSelectionManager = gridRowSelectionManagerSelector(apiRef)) => {\n  const filteredRows = gridFilteredRowsLookupSelector(apiRef);\n  const selectedDescendants = new Set([]);\n  if (!autoSelectDescendants && !autoSelectParents || filteredRows[selectedRow] === false) {\n    return;\n  }\n  if (autoSelectDescendants) {\n    const rowNode = tree[selectedRow];\n    if (rowNode?.type === 'group') {\n      const descendants = getGridRowGroupSelectableDescendants(apiRef, selectedRow);\n      descendants.forEach(rowId => {\n        addRow(rowId);\n        selectedDescendants.add(rowId);\n      });\n    }\n  }\n  if (autoSelectParents) {\n    const checkAllDescendantsSelected = rowId => {\n      if (!rowSelectionManager.has(rowId) && !selectedDescendants.has(rowId)) {\n        return false;\n      }\n      const node = tree[rowId];\n      if (!node) {\n        return false;\n      }\n      if (node.type !== 'group') {\n        return true;\n      }\n      return node.children.every(checkAllDescendantsSelected);\n    };\n    const traverseParents = rowId => {\n      const siblings = getFilteredRowNodeSiblings(tree, filteredRows, rowId);\n      if (siblings.length === 0 || siblings.every(checkAllDescendantsSelected)) {\n        const rowNode = tree[rowId];\n        const parent = rowNode?.parent;\n        if (parent != null && parent !== GRID_ROOT_GROUP_ID && apiRef.current.isRowSelectable(parent)) {\n          addRow(parent);\n          selectedDescendants.add(parent);\n          traverseParents(parent);\n        }\n      }\n    };\n    traverseParents(selectedRow);\n  }\n};\nexport const findRowsToDeselect = (apiRef, tree, deselectedRow, autoSelectDescendants, autoSelectParents, removeRow) => {\n  const rowSelectionManager = gridRowSelectionManagerSelector(apiRef);\n  if (!autoSelectParents && !autoSelectDescendants) {\n    return;\n  }\n  if (autoSelectParents) {\n    const allParents = getRowNodeParents(tree, deselectedRow);\n    allParents.forEach(parent => {\n      const isSelected = rowSelectionManager.has(parent);\n      if (isSelected) {\n        removeRow(parent);\n      }\n    });\n  }\n  if (autoSelectDescendants) {\n    const rowNode = tree[deselectedRow];\n    if (rowNode?.type === 'group') {\n      const descendants = getGridRowGroupSelectableDescendants(apiRef, deselectedRow);\n      descendants.forEach(descendant => {\n        removeRow(descendant);\n      });\n    }\n  }\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}