{"ast":null,"code":"import { isLeaf } from \"../../../models/gridColumnGrouping.js\";\n// This is the recurrence function that help writing `unwrapGroupingColumnModel()`\nconst recurrentUnwrapGroupingColumnModel = (columnGroupNode, parents, unwrappedGroupingModelToComplete) => {\n  if (isLeaf(columnGroupNode)) {\n    if (unwrappedGroupingModelToComplete[columnGroupNode.field] !== undefined) {\n      throw new Error([\"MUI X: columnGroupingModel contains duplicated field\", \"column field \".concat(columnGroupNode.field, \" occurs two times in the grouping model:\"), \"- \".concat(unwrappedGroupingModelToComplete[columnGroupNode.field].join(' > ')), \"- \".concat(parents.join(' > '))].join('\\n'));\n    }\n    unwrappedGroupingModelToComplete[columnGroupNode.field] = parents;\n    return;\n  }\n  const {\n    groupId,\n    children\n  } = columnGroupNode;\n  children.forEach(child => {\n    recurrentUnwrapGroupingColumnModel(child, [...parents, groupId], unwrappedGroupingModelToComplete);\n  });\n};\n\n/**\n * This is a function that provide for each column the array of its parents.\n * Parents are ordered from the root to the leaf.\n * @param columnGroupingModel The model such as provided in DataGrid props\n * @returns An object `{[field]: groupIds}` where `groupIds` is the parents of the column `field`\n */\nexport const unwrapGroupingColumnModel = columnGroupingModel => {\n  if (!columnGroupingModel) {\n    return {};\n  }\n  const unwrappedSubTree = {};\n  columnGroupingModel.forEach(columnGroupNode => {\n    recurrentUnwrapGroupingColumnModel(columnGroupNode, [], unwrappedSubTree);\n  });\n  return unwrappedSubTree;\n};\nexport const getColumnGroupsHeaderStructure = (orderedColumns, unwrappedGroupingModel, pinnedFields) => {\n  const getParents = field => {\n    var _unwrappedGroupingMod;\n    return (_unwrappedGroupingMod = unwrappedGroupingModel[field]) !== null && _unwrappedGroupingMod !== void 0 ? _unwrappedGroupingMod : [];\n  };\n  const groupingHeaderStructure = [];\n  const maxDepth = Math.max(0, ...orderedColumns.map(field => getParents(field).length));\n  const haveSameParents = (field1, field2, depth) => {\n    const a = getParents(field1);\n    const b = getParents(field2);\n    for (let i = 0; i <= depth; i += 1) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  };\n  const haveDifferentContainers = (field1, field2) => {\n    const left = pinnedFields === null || pinnedFields === void 0 ? void 0 : pinnedFields.left;\n    const right = pinnedFields === null || pinnedFields === void 0 ? void 0 : pinnedFields.right;\n    const inLeft1 = !!(left !== null && left !== void 0 && left.includes(field1));\n    const inLeft2 = !!(left !== null && left !== void 0 && left.includes(field2));\n    const inRight1 = !!(right !== null && right !== void 0 && right.includes(field1));\n    const inRight2 = !!(right !== null && right !== void 0 && right.includes(field2));\n    return inLeft1 !== inLeft2 || inRight1 !== inRight2;\n  };\n  for (let depth = 0; depth < maxDepth; depth += 1) {\n    const depthStructure = [];\n    for (let i = 0; i < orderedColumns.length; i += 1) {\n      var _getParents$depth;\n      const field = orderedColumns[i];\n      const groupId = (_getParents$depth = getParents(field)[depth]) !== null && _getParents$depth !== void 0 ? _getParents$depth : null;\n      if (depthStructure.length === 0) {\n        depthStructure.push({\n          columnFields: [field],\n          groupId\n        });\n        continue;\n      }\n      const lastGroup = depthStructure[depthStructure.length - 1];\n      const prevField = lastGroup.columnFields[lastGroup.columnFields.length - 1];\n      if (lastGroup.groupId !== groupId || !haveSameParents(prevField, field, depth) || haveDifferentContainers(prevField, field)) {\n        depthStructure.push({\n          columnFields: [field],\n          groupId\n        });\n      } else {\n        lastGroup.columnFields.push(field);\n      }\n    }\n    groupingHeaderStructure.push(depthStructure);\n  }\n  return groupingHeaderStructure;\n};","map":{"version":3,"names":["isLeaf","recurrentUnwrapGroupingColumnModel","columnGroupNode","parents","unwrappedGroupingModelToComplete","field","undefined","Error","concat","join","groupId","children","forEach","child","unwrapGroupingColumnModel","columnGroupingModel","unwrappedSubTree","getColumnGroupsHeaderStructure","orderedColumns","unwrappedGroupingModel","pinnedFields","getParents","_unwrappedGroupingMod","groupingHeaderStructure","maxDepth","Math","max","map","length","haveSameParents","field1","field2","depth","a","b","i","haveDifferentContainers","left","right","inLeft1","includes","inLeft2","inRight1","inRight2","depthStructure","_getParents$depth","push","columnFields","lastGroup","prevField"],"sources":["C:/Users/mis/rbt-dashboard/node_modules/@mui/x-data-grid/esm/hooks/features/columnGrouping/gridColumnGroupsUtils.js"],"sourcesContent":["import { isLeaf } from \"../../../models/gridColumnGrouping.js\";\n// This is the recurrence function that help writing `unwrapGroupingColumnModel()`\nconst recurrentUnwrapGroupingColumnModel = (columnGroupNode, parents, unwrappedGroupingModelToComplete) => {\n  if (isLeaf(columnGroupNode)) {\n    if (unwrappedGroupingModelToComplete[columnGroupNode.field] !== undefined) {\n      throw new Error([`MUI X: columnGroupingModel contains duplicated field`, `column field ${columnGroupNode.field} occurs two times in the grouping model:`, `- ${unwrappedGroupingModelToComplete[columnGroupNode.field].join(' > ')}`, `- ${parents.join(' > ')}`].join('\\n'));\n    }\n    unwrappedGroupingModelToComplete[columnGroupNode.field] = parents;\n    return;\n  }\n  const {\n    groupId,\n    children\n  } = columnGroupNode;\n  children.forEach(child => {\n    recurrentUnwrapGroupingColumnModel(child, [...parents, groupId], unwrappedGroupingModelToComplete);\n  });\n};\n\n/**\n * This is a function that provide for each column the array of its parents.\n * Parents are ordered from the root to the leaf.\n * @param columnGroupingModel The model such as provided in DataGrid props\n * @returns An object `{[field]: groupIds}` where `groupIds` is the parents of the column `field`\n */\nexport const unwrapGroupingColumnModel = columnGroupingModel => {\n  if (!columnGroupingModel) {\n    return {};\n  }\n  const unwrappedSubTree = {};\n  columnGroupingModel.forEach(columnGroupNode => {\n    recurrentUnwrapGroupingColumnModel(columnGroupNode, [], unwrappedSubTree);\n  });\n  return unwrappedSubTree;\n};\nexport const getColumnGroupsHeaderStructure = (orderedColumns, unwrappedGroupingModel, pinnedFields) => {\n  const getParents = field => unwrappedGroupingModel[field] ?? [];\n  const groupingHeaderStructure = [];\n  const maxDepth = Math.max(0, ...orderedColumns.map(field => getParents(field).length));\n  const haveSameParents = (field1, field2, depth) => {\n    const a = getParents(field1);\n    const b = getParents(field2);\n    for (let i = 0; i <= depth; i += 1) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  };\n  const haveDifferentContainers = (field1, field2) => {\n    const left = pinnedFields?.left;\n    const right = pinnedFields?.right;\n    const inLeft1 = !!left?.includes(field1);\n    const inLeft2 = !!left?.includes(field2);\n    const inRight1 = !!right?.includes(field1);\n    const inRight2 = !!right?.includes(field2);\n    return inLeft1 !== inLeft2 || inRight1 !== inRight2;\n  };\n  for (let depth = 0; depth < maxDepth; depth += 1) {\n    const depthStructure = [];\n    for (let i = 0; i < orderedColumns.length; i += 1) {\n      const field = orderedColumns[i];\n      const groupId = getParents(field)[depth] ?? null;\n      if (depthStructure.length === 0) {\n        depthStructure.push({\n          columnFields: [field],\n          groupId\n        });\n        continue;\n      }\n      const lastGroup = depthStructure[depthStructure.length - 1];\n      const prevField = lastGroup.columnFields[lastGroup.columnFields.length - 1];\n      if (lastGroup.groupId !== groupId || !haveSameParents(prevField, field, depth) || haveDifferentContainers(prevField, field)) {\n        depthStructure.push({\n          columnFields: [field],\n          groupId\n        });\n      } else {\n        lastGroup.columnFields.push(field);\n      }\n    }\n    groupingHeaderStructure.push(depthStructure);\n  }\n  return groupingHeaderStructure;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}