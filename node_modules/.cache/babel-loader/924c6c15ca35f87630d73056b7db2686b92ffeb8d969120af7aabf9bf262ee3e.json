{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nexport let DataSourceRowsUpdateStrategy = /*#__PURE__*/function (DataSourceRowsUpdateStrategy) {\n  DataSourceRowsUpdateStrategy[\"Default\"] = \"set-new-rows\";\n  DataSourceRowsUpdateStrategy[\"LazyLoading\"] = \"replace-row-range\";\n  return DataSourceRowsUpdateStrategy;\n}({});\n\n/**\n * Provides better cache hit rate by:\n * 1. Splitting the data into smaller chunks to be stored in the cache (cache `set`)\n * 2. Merging multiple cache entries into a single response to get the required chunk (cache `get`)\n */\nexport class CacheChunkManager {\n  /**\n   * @param chunkSize The number of rows to store in each cache entry.\n   * If not set, the whole array will be stored in a single cache entry.\n   * Setting this value to smallest page size will result in better cache hit rate.\n   * Has no effect if cursor pagination is used.\n   */\n  constructor(chunkSize) {\n    this.chunkSize = void 0;\n    this.getCacheKeys = key => {\n      if (this.chunkSize < 1 || typeof key.start !== 'number') {\n        return [key];\n      }\n\n      // split the range into chunks\n      const chunkedKeys = [];\n      for (let i = key.start; i <= key.end; i += this.chunkSize) {\n        const end = Math.min(i + this.chunkSize - 1, key.end);\n        chunkedKeys.push(_extends({}, key, {\n          start: i,\n          end\n        }));\n      }\n      return chunkedKeys;\n    };\n    this.splitResponse = (key, response) => {\n      const cacheKeys = this.getCacheKeys(key);\n      if (cacheKeys.length === 1) {\n        return new Map([[key, response]]);\n      }\n      const responses = new Map();\n      cacheKeys.forEach(chunkKey => {\n        const isLastChunk = chunkKey.end === key.end;\n        const responseSlice = _extends({}, response, {\n          pageInfo: _extends({}, response.pageInfo, {\n            // If the original response had page info, update that information for all but last chunk and keep the original value for the last chunk\n            hasNextPage: response.pageInfo?.hasNextPage !== undefined && !isLastChunk ? true : response.pageInfo?.hasNextPage,\n            nextCursor: response.pageInfo?.nextCursor !== undefined && !isLastChunk ? response.rows[chunkKey.end + 1].id : response.pageInfo?.nextCursor\n          }),\n          rows: typeof chunkKey.start !== 'number' || typeof key.start !== 'number' ? response.rows : response.rows.slice(chunkKey.start - key.start, chunkKey.end - key.start + 1)\n        });\n        responses.set(chunkKey, responseSlice);\n      });\n      return responses;\n    };\n    this.chunkSize = chunkSize;\n  }\n}\nCacheChunkManager.mergeResponses = responses => {\n  if (responses.length === 1) {\n    return responses[0];\n  }\n  return responses.reduce((acc, response) => ({\n    rows: [...acc.rows, ...response.rows],\n    rowCount: response.rowCount,\n    pageInfo: response.pageInfo\n  }), {\n    rows: [],\n    rowCount: 0,\n    pageInfo: {}\n  });\n};","map":{"version":3,"names":["_extends","DataSourceRowsUpdateStrategy","CacheChunkManager","constructor","chunkSize","getCacheKeys","key","start","chunkedKeys","i","end","Math","min","push","splitResponse","response","cacheKeys","length","Map","responses","forEach","chunkKey","isLastChunk","responseSlice","pageInfo","hasNextPage","undefined","nextCursor","rows","id","slice","set","mergeResponses","reduce","acc","rowCount"],"sources":["C:/Users/mis/rbt-dashboard/node_modules/@mui/x-data-grid/esm/hooks/features/dataSource/utils.js"],"sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nexport let DataSourceRowsUpdateStrategy = /*#__PURE__*/function (DataSourceRowsUpdateStrategy) {\n  DataSourceRowsUpdateStrategy[\"Default\"] = \"set-new-rows\";\n  DataSourceRowsUpdateStrategy[\"LazyLoading\"] = \"replace-row-range\";\n  return DataSourceRowsUpdateStrategy;\n}({});\n\n/**\n * Provides better cache hit rate by:\n * 1. Splitting the data into smaller chunks to be stored in the cache (cache `set`)\n * 2. Merging multiple cache entries into a single response to get the required chunk (cache `get`)\n */\nexport class CacheChunkManager {\n  /**\n   * @param chunkSize The number of rows to store in each cache entry.\n   * If not set, the whole array will be stored in a single cache entry.\n   * Setting this value to smallest page size will result in better cache hit rate.\n   * Has no effect if cursor pagination is used.\n   */\n  constructor(chunkSize) {\n    this.chunkSize = void 0;\n    this.getCacheKeys = key => {\n      if (this.chunkSize < 1 || typeof key.start !== 'number') {\n        return [key];\n      }\n\n      // split the range into chunks\n      const chunkedKeys = [];\n      for (let i = key.start; i <= key.end; i += this.chunkSize) {\n        const end = Math.min(i + this.chunkSize - 1, key.end);\n        chunkedKeys.push(_extends({}, key, {\n          start: i,\n          end\n        }));\n      }\n      return chunkedKeys;\n    };\n    this.splitResponse = (key, response) => {\n      const cacheKeys = this.getCacheKeys(key);\n      if (cacheKeys.length === 1) {\n        return new Map([[key, response]]);\n      }\n      const responses = new Map();\n      cacheKeys.forEach(chunkKey => {\n        const isLastChunk = chunkKey.end === key.end;\n        const responseSlice = _extends({}, response, {\n          pageInfo: _extends({}, response.pageInfo, {\n            // If the original response had page info, update that information for all but last chunk and keep the original value for the last chunk\n            hasNextPage: response.pageInfo?.hasNextPage !== undefined && !isLastChunk ? true : response.pageInfo?.hasNextPage,\n            nextCursor: response.pageInfo?.nextCursor !== undefined && !isLastChunk ? response.rows[chunkKey.end + 1].id : response.pageInfo?.nextCursor\n          }),\n          rows: typeof chunkKey.start !== 'number' || typeof key.start !== 'number' ? response.rows : response.rows.slice(chunkKey.start - key.start, chunkKey.end - key.start + 1)\n        });\n        responses.set(chunkKey, responseSlice);\n      });\n      return responses;\n    };\n    this.chunkSize = chunkSize;\n  }\n}\nCacheChunkManager.mergeResponses = responses => {\n  if (responses.length === 1) {\n    return responses[0];\n  }\n  return responses.reduce((acc, response) => ({\n    rows: [...acc.rows, ...response.rows],\n    rowCount: response.rowCount,\n    pageInfo: response.pageInfo\n  }), {\n    rows: [],\n    rowCount: 0,\n    pageInfo: {}\n  });\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}