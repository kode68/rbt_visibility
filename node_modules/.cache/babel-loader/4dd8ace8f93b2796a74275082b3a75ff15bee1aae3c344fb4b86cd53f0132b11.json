{"ast":null,"code":"import useEventCallback from '@mui/utils/useEventCallback';\n\n/* eslint-disable import/export, @typescript-eslint/no-redeclare */\n\nconst selectors = {};\nexport const Colspan = {\n  initialize: initializeState,\n  use: useColspan,\n  selectors\n};\nfunction initializeState(_params) {\n  return {\n    colspanMap: new Map()\n  };\n}\nfunction useColspan(store, params, api) {\n  const resetColSpan = () => {\n    store.state.colspanMap = new Map();\n  };\n  const getCellColSpanInfo = (rowId, columnIndex) => {\n    return store.state.colspanMap.get(rowId)?.[columnIndex];\n  };\n\n  // Calculate `colSpan` for each cell in the row\n  const calculateColSpan = useEventCallback((rowId, minFirstColumn, maxLastColumn, columns) => {\n    for (let i = minFirstColumn; i < maxLastColumn; i += 1) {\n      const cellProps = calculateCellColSpan(store.state.colspanMap, i, rowId, minFirstColumn, maxLastColumn, columns, params.getColspan);\n      if (cellProps.colSpan > 1) {\n        i += cellProps.colSpan - 1;\n      }\n    }\n  });\n  api.calculateColSpan = calculateColSpan;\n  return {\n    resetColSpan,\n    getCellColSpanInfo,\n    calculateColSpan\n  };\n}\nfunction calculateCellColSpan(lookup, columnIndex, rowId, minFirstColumnIndex, maxLastColumnIndex, columns, getColspan) {\n  const columnsLength = columns.length;\n  const column = columns[columnIndex];\n  const colSpan = getColspan(rowId, column, columnIndex);\n  if (!colSpan || colSpan === 1) {\n    setCellColSpanInfo(lookup, rowId, columnIndex, {\n      spannedByColSpan: false,\n      cellProps: {\n        colSpan: 1,\n        width: column.computedWidth\n      }\n    });\n    return {\n      colSpan: 1\n    };\n  }\n  let width = column.computedWidth;\n  for (let j = 1; j < colSpan; j += 1) {\n    const nextColumnIndex = columnIndex + j;\n    // Cells should be spanned only within their column section (left-pinned, right-pinned and unpinned).\n    if (nextColumnIndex >= minFirstColumnIndex && nextColumnIndex < maxLastColumnIndex) {\n      const nextColumn = columns[nextColumnIndex];\n      width += nextColumn.computedWidth;\n      setCellColSpanInfo(lookup, rowId, columnIndex + j, {\n        spannedByColSpan: true,\n        rightVisibleCellIndex: Math.min(columnIndex + colSpan, columnsLength - 1),\n        leftVisibleCellIndex: columnIndex\n      });\n    }\n    setCellColSpanInfo(lookup, rowId, columnIndex, {\n      spannedByColSpan: false,\n      cellProps: {\n        colSpan,\n        width\n      }\n    });\n  }\n  return {\n    colSpan\n  };\n}\nfunction setCellColSpanInfo(colspanMap, rowId, columnIndex, cellColSpanInfo) {\n  let columnInfo = colspanMap.get(rowId);\n  if (!columnInfo) {\n    columnInfo = {};\n    colspanMap.set(rowId, columnInfo);\n  }\n  columnInfo[columnIndex] = cellColSpanInfo;\n}","map":{"version":3,"names":["useEventCallback","selectors","Colspan","initialize","initializeState","use","useColspan","_params","colspanMap","Map","store","params","api","resetColSpan","state","getCellColSpanInfo","rowId","columnIndex","get","calculateColSpan","minFirstColumn","maxLastColumn","columns","i","cellProps","calculateCellColSpan","getColspan","colSpan","lookup","minFirstColumnIndex","maxLastColumnIndex","columnsLength","length","column","setCellColSpanInfo","spannedByColSpan","width","computedWidth","j","nextColumnIndex","nextColumn","rightVisibleCellIndex","Math","min","leftVisibleCellIndex","cellColSpanInfo","columnInfo","set"],"sources":["C:/Users/mis/rbt-dashboard/node_modules/@mui/x-virtualizer/esm/features/colspan.js"],"sourcesContent":["import useEventCallback from '@mui/utils/useEventCallback';\n\n/* eslint-disable import/export, @typescript-eslint/no-redeclare */\n\nconst selectors = {};\nexport const Colspan = {\n  initialize: initializeState,\n  use: useColspan,\n  selectors\n};\nfunction initializeState(_params) {\n  return {\n    colspanMap: new Map()\n  };\n}\nfunction useColspan(store, params, api) {\n  const resetColSpan = () => {\n    store.state.colspanMap = new Map();\n  };\n  const getCellColSpanInfo = (rowId, columnIndex) => {\n    return store.state.colspanMap.get(rowId)?.[columnIndex];\n  };\n\n  // Calculate `colSpan` for each cell in the row\n  const calculateColSpan = useEventCallback((rowId, minFirstColumn, maxLastColumn, columns) => {\n    for (let i = minFirstColumn; i < maxLastColumn; i += 1) {\n      const cellProps = calculateCellColSpan(store.state.colspanMap, i, rowId, minFirstColumn, maxLastColumn, columns, params.getColspan);\n      if (cellProps.colSpan > 1) {\n        i += cellProps.colSpan - 1;\n      }\n    }\n  });\n  api.calculateColSpan = calculateColSpan;\n  return {\n    resetColSpan,\n    getCellColSpanInfo,\n    calculateColSpan\n  };\n}\nfunction calculateCellColSpan(lookup, columnIndex, rowId, minFirstColumnIndex, maxLastColumnIndex, columns, getColspan) {\n  const columnsLength = columns.length;\n  const column = columns[columnIndex];\n  const colSpan = getColspan(rowId, column, columnIndex);\n  if (!colSpan || colSpan === 1) {\n    setCellColSpanInfo(lookup, rowId, columnIndex, {\n      spannedByColSpan: false,\n      cellProps: {\n        colSpan: 1,\n        width: column.computedWidth\n      }\n    });\n    return {\n      colSpan: 1\n    };\n  }\n  let width = column.computedWidth;\n  for (let j = 1; j < colSpan; j += 1) {\n    const nextColumnIndex = columnIndex + j;\n    // Cells should be spanned only within their column section (left-pinned, right-pinned and unpinned).\n    if (nextColumnIndex >= minFirstColumnIndex && nextColumnIndex < maxLastColumnIndex) {\n      const nextColumn = columns[nextColumnIndex];\n      width += nextColumn.computedWidth;\n      setCellColSpanInfo(lookup, rowId, columnIndex + j, {\n        spannedByColSpan: true,\n        rightVisibleCellIndex: Math.min(columnIndex + colSpan, columnsLength - 1),\n        leftVisibleCellIndex: columnIndex\n      });\n    }\n    setCellColSpanInfo(lookup, rowId, columnIndex, {\n      spannedByColSpan: false,\n      cellProps: {\n        colSpan,\n        width\n      }\n    });\n  }\n  return {\n    colSpan\n  };\n}\nfunction setCellColSpanInfo(colspanMap, rowId, columnIndex, cellColSpanInfo) {\n  let columnInfo = colspanMap.get(rowId);\n  if (!columnInfo) {\n    columnInfo = {};\n    colspanMap.set(rowId, columnInfo);\n  }\n  columnInfo[columnIndex] = cellColSpanInfo;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}